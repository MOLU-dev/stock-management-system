// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    sku, name, description, category_id, unit_price, cost_price,
    barcode, weight, dimensions, supplier_id, min_stock_level,
    max_stock_level, reorder_point, safety_stock, lead_time_days,
    auto_reorder, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) RETURNING product_id, sku, name, description, category_id, unit_price, cost_price, barcode, weight, dimensions, supplier_id, min_stock_level, max_stock_level, reorder_point, safety_stock, lead_time_days, auto_reorder, last_reorder_date, is_active, created_at, updated_at
`

type CreateProductParams struct {
	Sku           string          `json:"sku"`
	Name          string          `json:"name"`
	Description   pgtype.Text     `json:"description"`
	CategoryID    pgtype.Int4     `json:"category_id"`
	UnitPrice     decimal.Decimal `json:"unit_price"`
	CostPrice     decimal.Decimal `json:"cost_price"`
	Barcode       pgtype.Text     `json:"barcode"`
	Weight        decimal.Decimal `json:"weight"`
	Dimensions    pgtype.Text     `json:"dimensions"`
	SupplierID    pgtype.Int4     `json:"supplier_id"`
	MinStockLevel pgtype.Int4     `json:"min_stock_level"`
	MaxStockLevel pgtype.Int4     `json:"max_stock_level"`
	ReorderPoint  pgtype.Int4     `json:"reorder_point"`
	SafetyStock   pgtype.Int4     `json:"safety_stock"`
	LeadTimeDays  pgtype.Int4     `json:"lead_time_days"`
	AutoReorder   pgtype.Bool     `json:"auto_reorder"`
	IsActive      pgtype.Bool     `json:"is_active"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg *CreateProductParams) (*Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Sku,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.UnitPrice,
		arg.CostPrice,
		arg.Barcode,
		arg.Weight,
		arg.Dimensions,
		arg.SupplierID,
		arg.MinStockLevel,
		arg.MaxStockLevel,
		arg.ReorderPoint,
		arg.SafetyStock,
		arg.LeadTimeDays,
		arg.AutoReorder,
		arg.IsActive,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.UnitPrice,
		&i.CostPrice,
		&i.Barcode,
		&i.Weight,
		&i.Dimensions,
		&i.SupplierID,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.ReorderPoint,
		&i.SafetyStock,
		&i.LeadTimeDays,
		&i.AutoReorder,
		&i.LastReorderDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProduct = `-- name: GetProduct :one
SELECT product_id, sku, name, description, category_id, unit_price, cost_price, barcode, weight, dimensions, supplier_id, min_stock_level, max_stock_level, reorder_point, safety_stock, lead_time_days, auto_reorder, last_reorder_date, is_active, created_at, updated_at FROM products 
WHERE product_id = $1
`

func (q *Queries) GetProduct(ctx context.Context, productID int32) (*Product, error) {
	row := q.db.QueryRow(ctx, getProduct, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.UnitPrice,
		&i.CostPrice,
		&i.Barcode,
		&i.Weight,
		&i.Dimensions,
		&i.SupplierID,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.ReorderPoint,
		&i.SafetyStock,
		&i.LeadTimeDays,
		&i.AutoReorder,
		&i.LastReorderDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProductBySKU = `-- name: GetProductBySKU :one
SELECT product_id, sku, name, description, category_id, unit_price, cost_price, barcode, weight, dimensions, supplier_id, min_stock_level, max_stock_level, reorder_point, safety_stock, lead_time_days, auto_reorder, last_reorder_date, is_active, created_at, updated_at FROM products 
WHERE sku = $1
`

func (q *Queries) GetProductBySKU(ctx context.Context, sku string) (*Product, error) {
	row := q.db.QueryRow(ctx, getProductBySKU, sku)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.UnitPrice,
		&i.CostPrice,
		&i.Barcode,
		&i.Weight,
		&i.Dimensions,
		&i.SupplierID,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.ReorderPoint,
		&i.SafetyStock,
		&i.LeadTimeDays,
		&i.AutoReorder,
		&i.LastReorderDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listProducts = `-- name: ListProducts :many
SELECT product_id, sku, name, description, category_id, unit_price, cost_price, barcode, weight, dimensions, supplier_id, min_stock_level, max_stock_level, reorder_point, safety_stock, lead_time_days, auto_reorder, last_reorder_date, is_active, created_at, updated_at FROM products 
WHERE is_active = true
ORDER BY product_id
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg *ListProductsParams) ([]*Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.UnitPrice,
			&i.CostPrice,
			&i.Barcode,
			&i.Weight,
			&i.Dimensions,
			&i.SupplierID,
			&i.MinStockLevel,
			&i.MaxStockLevel,
			&i.ReorderPoint,
			&i.SafetyStock,
			&i.LeadTimeDays,
			&i.AutoReorder,
			&i.LastReorderDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsBelowReorderPoint = `-- name: ListProductsBelowReorderPoint :many
SELECT p.product_id, p.sku, p.name, p.description, p.category_id, p.unit_price, p.cost_price, p.barcode, p.weight, p.dimensions, p.supplier_id, p.min_stock_level, p.max_stock_level, p.reorder_point, p.safety_stock, p.lead_time_days, p.auto_reorder, p.last_reorder_date, p.is_active, p.created_at, p.updated_at,
       COALESCE(SUM(i.quantity - i.reserved_quantity), 0) as available_qty
FROM products p
LEFT JOIN inventory i ON p.product_id = i.product_id
WHERE p.is_active = true
GROUP BY p.product_id
HAVING COALESCE(SUM(i.quantity - i.reserved_quantity), 0) <= p.reorder_point
ORDER BY p.product_id
`

type ListProductsBelowReorderPointRow struct {
	ProductID       int32           `json:"product_id"`
	Sku             string          `json:"sku"`
	Name            string          `json:"name"`
	Description     pgtype.Text     `json:"description"`
	CategoryID      pgtype.Int4     `json:"category_id"`
	UnitPrice       decimal.Decimal `json:"unit_price"`
	CostPrice       decimal.Decimal `json:"cost_price"`
	Barcode         pgtype.Text     `json:"barcode"`
	Weight          decimal.Decimal `json:"weight"`
	Dimensions      pgtype.Text     `json:"dimensions"`
	SupplierID      pgtype.Int4     `json:"supplier_id"`
	MinStockLevel   pgtype.Int4     `json:"min_stock_level"`
	MaxStockLevel   pgtype.Int4     `json:"max_stock_level"`
	ReorderPoint    pgtype.Int4     `json:"reorder_point"`
	SafetyStock     pgtype.Int4     `json:"safety_stock"`
	LeadTimeDays    pgtype.Int4     `json:"lead_time_days"`
	AutoReorder     pgtype.Bool     `json:"auto_reorder"`
	LastReorderDate time.Time       `json:"last_reorder_date"`
	IsActive        pgtype.Bool     `json:"is_active"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	AvailableQty    interface{}     `json:"available_qty"`
}

func (q *Queries) ListProductsBelowReorderPoint(ctx context.Context) ([]*ListProductsBelowReorderPointRow, error) {
	rows, err := q.db.Query(ctx, listProductsBelowReorderPoint)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListProductsBelowReorderPointRow
	for rows.Next() {
		var i ListProductsBelowReorderPointRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.UnitPrice,
			&i.CostPrice,
			&i.Barcode,
			&i.Weight,
			&i.Dimensions,
			&i.SupplierID,
			&i.MinStockLevel,
			&i.MaxStockLevel,
			&i.ReorderPoint,
			&i.SafetyStock,
			&i.LeadTimeDays,
			&i.AutoReorder,
			&i.LastReorderDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableQty,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT product_id, sku, name, description, category_id, unit_price, cost_price, barcode, weight, dimensions, supplier_id, min_stock_level, max_stock_level, reorder_point, safety_stock, lead_time_days, auto_reorder, last_reorder_date, is_active, created_at, updated_at FROM products 
WHERE category_id = $1 AND is_active = true
ORDER BY product_id
LIMIT $2 OFFSET $3
`

type ListProductsByCategoryParams struct {
	CategoryID pgtype.Int4 `json:"category_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg *ListProductsByCategoryParams) ([]*Product, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.UnitPrice,
			&i.CostPrice,
			&i.Barcode,
			&i.Weight,
			&i.Dimensions,
			&i.SupplierID,
			&i.MinStockLevel,
			&i.MaxStockLevel,
			&i.ReorderPoint,
			&i.SafetyStock,
			&i.LeadTimeDays,
			&i.AutoReorder,
			&i.LastReorderDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE products 
SET is_active = false, updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, productID int32) error {
	_, err := q.db.Exec(ctx, softDeleteProduct, productID)
	return err
}

const updateLastReorderDate = `-- name: UpdateLastReorderDate :exec
UPDATE products 
SET last_reorder_date = CURRENT_DATE, updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1
`

func (q *Queries) UpdateLastReorderDate(ctx context.Context, productID int32) error {
	_, err := q.db.Exec(ctx, updateLastReorderDate, productID)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products 
SET 
    name = $2,
    description = $3,
    category_id = $4,
    unit_price = $5,
    cost_price = $6,
    barcode = $7,
    weight = $8,
    dimensions = $9,
    supplier_id = $10,
    min_stock_level = $11,
    max_stock_level = $12,
    reorder_point = $13,
    safety_stock = $14,
    lead_time_days = $15,
    auto_reorder = $16,
    is_active = $17,
    updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1
RETURNING product_id, sku, name, description, category_id, unit_price, cost_price, barcode, weight, dimensions, supplier_id, min_stock_level, max_stock_level, reorder_point, safety_stock, lead_time_days, auto_reorder, last_reorder_date, is_active, created_at, updated_at
`

type UpdateProductParams struct {
	ProductID     int32           `json:"product_id"`
	Name          string          `json:"name"`
	Description   pgtype.Text     `json:"description"`
	CategoryID    pgtype.Int4     `json:"category_id"`
	UnitPrice     decimal.Decimal `json:"unit_price"`
	CostPrice     decimal.Decimal `json:"cost_price"`
	Barcode       pgtype.Text     `json:"barcode"`
	Weight        decimal.Decimal `json:"weight"`
	Dimensions    pgtype.Text     `json:"dimensions"`
	SupplierID    pgtype.Int4     `json:"supplier_id"`
	MinStockLevel pgtype.Int4     `json:"min_stock_level"`
	MaxStockLevel pgtype.Int4     `json:"max_stock_level"`
	ReorderPoint  pgtype.Int4     `json:"reorder_point"`
	SafetyStock   pgtype.Int4     `json:"safety_stock"`
	LeadTimeDays  pgtype.Int4     `json:"lead_time_days"`
	AutoReorder   pgtype.Bool     `json:"auto_reorder"`
	IsActive      pgtype.Bool     `json:"is_active"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg *UpdateProductParams) (*Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ProductID,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.UnitPrice,
		arg.CostPrice,
		arg.Barcode,
		arg.Weight,
		arg.Dimensions,
		arg.SupplierID,
		arg.MinStockLevel,
		arg.MaxStockLevel,
		arg.ReorderPoint,
		arg.SafetyStock,
		arg.LeadTimeDays,
		arg.AutoReorder,
		arg.IsActive,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.UnitPrice,
		&i.CostPrice,
		&i.Barcode,
		&i.Weight,
		&i.Dimensions,
		&i.SupplierID,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.ReorderPoint,
		&i.SafetyStock,
		&i.LeadTimeDays,
		&i.AutoReorder,
		&i.LastReorderDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
