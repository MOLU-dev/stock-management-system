// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: warehouses.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (
  warehouse_id, location_code, aisle, shelf, bin, max_capacity
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING location_id, warehouse_id, location_code, aisle, shelf, bin, max_capacity, is_active
`

type CreateLocationParams struct {
	WarehouseID  int32       `json:"warehouse_id"`
	LocationCode string      `json:"location_code"`
	Aisle        pgtype.Text `json:"aisle"`
	Shelf        pgtype.Text `json:"shelf"`
	Bin          pgtype.Text `json:"bin"`
	MaxCapacity  pgtype.Int4 `json:"max_capacity"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg *CreateLocationParams) (*Location, error) {
	row := q.db.QueryRow(ctx, createLocation,
		arg.WarehouseID,
		arg.LocationCode,
		arg.Aisle,
		arg.Shelf,
		arg.Bin,
		arg.MaxCapacity,
	)
	var i Location
	err := row.Scan(
		&i.LocationID,
		&i.WarehouseID,
		&i.LocationCode,
		&i.Aisle,
		&i.Shelf,
		&i.Bin,
		&i.MaxCapacity,
		&i.IsActive,
	)
	return &i, err
}

const createWarehouse = `-- name: CreateWarehouse :one
INSERT INTO warehouses (
  code, name, address, contact_person, contact_phone, contact_email
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING warehouse_id, code, name, address, contact_person, contact_phone, contact_email, is_active, created_at
`

type CreateWarehouseParams struct {
	Code          string      `json:"code"`
	Name          string      `json:"name"`
	Address       pgtype.Text `json:"address"`
	ContactPerson pgtype.Text `json:"contact_person"`
	ContactPhone  pgtype.Text `json:"contact_phone"`
	ContactEmail  pgtype.Text `json:"contact_email"`
}

func (q *Queries) CreateWarehouse(ctx context.Context, arg *CreateWarehouseParams) (*Warehouse, error) {
	row := q.db.QueryRow(ctx, createWarehouse,
		arg.Code,
		arg.Name,
		arg.Address,
		arg.ContactPerson,
		arg.ContactPhone,
		arg.ContactEmail,
	)
	var i Warehouse
	err := row.Scan(
		&i.WarehouseID,
		&i.Code,
		&i.Name,
		&i.Address,
		&i.ContactPerson,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.IsActive,
		&i.CreatedAt,
	)
	return &i, err
}

const deactivateLocation = `-- name: DeactivateLocation :exec
UPDATE locations
SET is_active = false
WHERE location_id = $1
`

func (q *Queries) DeactivateLocation(ctx context.Context, locationID int32) error {
	_, err := q.db.Exec(ctx, deactivateLocation, locationID)
	return err
}

const deactivateWarehouse = `-- name: DeactivateWarehouse :exec
UPDATE warehouses
SET is_active = false
WHERE warehouse_id = $1
`

func (q *Queries) DeactivateWarehouse(ctx context.Context, warehouseID int32) error {
	_, err := q.db.Exec(ctx, deactivateWarehouse, warehouseID)
	return err
}

const getLocation = `-- name: GetLocation :one
SELECT location_id, warehouse_id, location_code, aisle, shelf, bin, max_capacity, is_active FROM locations WHERE location_id = $1
`

func (q *Queries) GetLocation(ctx context.Context, locationID int32) (*Location, error) {
	row := q.db.QueryRow(ctx, getLocation, locationID)
	var i Location
	err := row.Scan(
		&i.LocationID,
		&i.WarehouseID,
		&i.LocationCode,
		&i.Aisle,
		&i.Shelf,
		&i.Bin,
		&i.MaxCapacity,
		&i.IsActive,
	)
	return &i, err
}

const getLocationByCode = `-- name: GetLocationByCode :one
SELECT location_id, warehouse_id, location_code, aisle, shelf, bin, max_capacity, is_active FROM locations
WHERE warehouse_id = $1 AND location_code = $2
`

type GetLocationByCodeParams struct {
	WarehouseID  int32  `json:"warehouse_id"`
	LocationCode string `json:"location_code"`
}

func (q *Queries) GetLocationByCode(ctx context.Context, arg *GetLocationByCodeParams) (*Location, error) {
	row := q.db.QueryRow(ctx, getLocationByCode, arg.WarehouseID, arg.LocationCode)
	var i Location
	err := row.Scan(
		&i.LocationID,
		&i.WarehouseID,
		&i.LocationCode,
		&i.Aisle,
		&i.Shelf,
		&i.Bin,
		&i.MaxCapacity,
		&i.IsActive,
	)
	return &i, err
}

const getWarehouse = `-- name: GetWarehouse :one
SELECT warehouse_id, code, name, address, contact_person, contact_phone, contact_email, is_active, created_at FROM warehouses WHERE warehouse_id = $1
`

func (q *Queries) GetWarehouse(ctx context.Context, warehouseID int32) (*Warehouse, error) {
	row := q.db.QueryRow(ctx, getWarehouse, warehouseID)
	var i Warehouse
	err := row.Scan(
		&i.WarehouseID,
		&i.Code,
		&i.Name,
		&i.Address,
		&i.ContactPerson,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.IsActive,
		&i.CreatedAt,
	)
	return &i, err
}

const getWarehouseByCode = `-- name: GetWarehouseByCode :one
SELECT warehouse_id, code, name, address, contact_person, contact_phone, contact_email, is_active, created_at FROM warehouses WHERE code = $1
`

func (q *Queries) GetWarehouseByCode(ctx context.Context, code string) (*Warehouse, error) {
	row := q.db.QueryRow(ctx, getWarehouseByCode, code)
	var i Warehouse
	err := row.Scan(
		&i.WarehouseID,
		&i.Code,
		&i.Name,
		&i.Address,
		&i.ContactPerson,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.IsActive,
		&i.CreatedAt,
	)
	return &i, err
}

const getWarehouseInventorySummary = `-- name: GetWarehouseInventorySummary :many
SELECT 
  w.warehouse_id,
  w.name as warehouse_name,
  COUNT(DISTINCT i.product_id) as unique_products,
  COALESCE(SUM(i.quantity), 0) as total_items,
  COALESCE(SUM(i.reserved_quantity), 0) as reserved_items
FROM warehouses w
LEFT JOIN inventory i ON w.warehouse_id = i.warehouse_id
WHERE w.is_active = true
GROUP BY w.warehouse_id, w.name
ORDER BY w.name
`

type GetWarehouseInventorySummaryRow struct {
	WarehouseID    int32       `json:"warehouse_id"`
	WarehouseName  string      `json:"warehouse_name"`
	UniqueProducts int64       `json:"unique_products"`
	TotalItems     interface{} `json:"total_items"`
	ReservedItems  interface{} `json:"reserved_items"`
}

func (q *Queries) GetWarehouseInventorySummary(ctx context.Context) ([]*GetWarehouseInventorySummaryRow, error) {
	rows, err := q.db.Query(ctx, getWarehouseInventorySummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWarehouseInventorySummaryRow
	for rows.Next() {
		var i GetWarehouseInventorySummaryRow
		if err := rows.Scan(
			&i.WarehouseID,
			&i.WarehouseName,
			&i.UniqueProducts,
			&i.TotalItems,
			&i.ReservedItems,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllWarehouses = `-- name: ListAllWarehouses :many
SELECT warehouse_id, code, name, address, contact_person, contact_phone, contact_email, is_active, created_at FROM warehouses
ORDER BY name
`

func (q *Queries) ListAllWarehouses(ctx context.Context) ([]*Warehouse, error) {
	rows, err := q.db.Query(ctx, listAllWarehouses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Warehouse
	for rows.Next() {
		var i Warehouse
		if err := rows.Scan(
			&i.WarehouseID,
			&i.Code,
			&i.Name,
			&i.Address,
			&i.ContactPerson,
			&i.ContactPhone,
			&i.ContactEmail,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationsByWarehouse = `-- name: ListLocationsByWarehouse :many
SELECT location_id, warehouse_id, location_code, aisle, shelf, bin, max_capacity, is_active FROM locations
WHERE warehouse_id = $1 AND is_active = true
ORDER BY location_code
`

func (q *Queries) ListLocationsByWarehouse(ctx context.Context, warehouseID int32) ([]*Location, error) {
	rows, err := q.db.Query(ctx, listLocationsByWarehouse, warehouseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Location
	for rows.Next() {
		var i Location
		if err := rows.Scan(
			&i.LocationID,
			&i.WarehouseID,
			&i.LocationCode,
			&i.Aisle,
			&i.Shelf,
			&i.Bin,
			&i.MaxCapacity,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWarehouses = `-- name: ListWarehouses :many
SELECT warehouse_id, code, name, address, contact_person, contact_phone, contact_email, is_active, created_at FROM warehouses
WHERE is_active = true
ORDER BY name
`

func (q *Queries) ListWarehouses(ctx context.Context) ([]*Warehouse, error) {
	rows, err := q.db.Query(ctx, listWarehouses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Warehouse
	for rows.Next() {
		var i Warehouse
		if err := rows.Scan(
			&i.WarehouseID,
			&i.Code,
			&i.Name,
			&i.Address,
			&i.ContactPerson,
			&i.ContactPhone,
			&i.ContactEmail,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLocation = `-- name: UpdateLocation :one
UPDATE locations
SET aisle = $2,
    shelf = $3,
    bin = $4,
    max_capacity = $5
WHERE location_id = $1
RETURNING location_id, warehouse_id, location_code, aisle, shelf, bin, max_capacity, is_active
`

type UpdateLocationParams struct {
	LocationID  int32       `json:"location_id"`
	Aisle       pgtype.Text `json:"aisle"`
	Shelf       pgtype.Text `json:"shelf"`
	Bin         pgtype.Text `json:"bin"`
	MaxCapacity pgtype.Int4 `json:"max_capacity"`
}

func (q *Queries) UpdateLocation(ctx context.Context, arg *UpdateLocationParams) (*Location, error) {
	row := q.db.QueryRow(ctx, updateLocation,
		arg.LocationID,
		arg.Aisle,
		arg.Shelf,
		arg.Bin,
		arg.MaxCapacity,
	)
	var i Location
	err := row.Scan(
		&i.LocationID,
		&i.WarehouseID,
		&i.LocationCode,
		&i.Aisle,
		&i.Shelf,
		&i.Bin,
		&i.MaxCapacity,
		&i.IsActive,
	)
	return &i, err
}

const updateWarehouse = `-- name: UpdateWarehouse :one
UPDATE warehouses
SET name = $2,
    address = $3,
    contact_person = $4,
    contact_phone = $5,
    contact_email = $6
WHERE warehouse_id = $1
RETURNING warehouse_id, code, name, address, contact_person, contact_phone, contact_email, is_active, created_at
`

type UpdateWarehouseParams struct {
	WarehouseID   int32       `json:"warehouse_id"`
	Name          string      `json:"name"`
	Address       pgtype.Text `json:"address"`
	ContactPerson pgtype.Text `json:"contact_person"`
	ContactPhone  pgtype.Text `json:"contact_phone"`
	ContactEmail  pgtype.Text `json:"contact_email"`
}

func (q *Queries) UpdateWarehouse(ctx context.Context, arg *UpdateWarehouseParams) (*Warehouse, error) {
	row := q.db.QueryRow(ctx, updateWarehouse,
		arg.WarehouseID,
		arg.Name,
		arg.Address,
		arg.ContactPerson,
		arg.ContactPhone,
		arg.ContactEmail,
	)
	var i Warehouse
	err := row.Scan(
		&i.WarehouseID,
		&i.Code,
		&i.Name,
		&i.Address,
		&i.ContactPerson,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.IsActive,
		&i.CreatedAt,
	)
	return &i, err
}
