// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stocktakes.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createStocktake = `-- name: CreateStocktake :one
INSERT INTO stock_takes (
  stocktake_number, warehouse_id, start_date, end_date, status, notes, created_by
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING stocktake_id, stocktake_number, warehouse_id, start_date, end_date, status, notes, created_by, created_at
`

type CreateStocktakeParams struct {
	StocktakeNumber string          `json:"stocktake_number"`
	WarehouseID     int32           `json:"warehouse_id"`
	StartDate       time.Time       `json:"start_date"`
	EndDate         time.Time       `json:"end_date"`
	Status          StocktakeStatus `json:"status"`
	Notes           sql.NullString  `json:"notes"`
	CreatedBy       sql.NullInt32   `json:"created_by"`
}

func (q *Queries) CreateStocktake(ctx context.Context, arg CreateStocktakeParams) (StockTake, error) {
	row := q.db.QueryRowContext(ctx, createStocktake,
		arg.StocktakeNumber,
		arg.WarehouseID,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.Notes,
		arg.CreatedBy,
	)
	var i StockTake
	err := row.Scan(
		&i.StocktakeID,
		&i.StocktakeNumber,
		&i.WarehouseID,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createStocktakeItem = `-- name: CreateStocktakeItem :one
INSERT INTO stocktake_items (
  stocktake_id, product_id, location_id, system_quantity,
  counted_quantity, variance, counted_by, counted_at, notes
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING stocktake_item_id, stocktake_id, product_id, location_id, system_quantity, counted_quantity, variance, counted_by, counted_at, notes
`

type CreateStocktakeItemParams struct {
	StocktakeID     int32          `json:"stocktake_id"`
	ProductID       int32          `json:"product_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	SystemQuantity  int32          `json:"system_quantity"`
	CountedQuantity sql.NullInt32  `json:"counted_quantity"`
	Variance        sql.NullInt32  `json:"variance"`
	CountedBy       sql.NullInt32  `json:"counted_by"`
	CountedAt       time.Time      `json:"counted_at"`
	Notes           sql.NullString `json:"notes"`
}

func (q *Queries) CreateStocktakeItem(ctx context.Context, arg CreateStocktakeItemParams) (StocktakeItem, error) {
	row := q.db.QueryRowContext(ctx, createStocktakeItem,
		arg.StocktakeID,
		arg.ProductID,
		arg.LocationID,
		arg.SystemQuantity,
		arg.CountedQuantity,
		arg.Variance,
		arg.CountedBy,
		arg.CountedAt,
		arg.Notes,
	)
	var i StocktakeItem
	err := row.Scan(
		&i.StocktakeItemID,
		&i.StocktakeID,
		&i.ProductID,
		&i.LocationID,
		&i.SystemQuantity,
		&i.CountedQuantity,
		&i.Variance,
		&i.CountedBy,
		&i.CountedAt,
		&i.Notes,
	)
	return i, err
}

const getActiveStocktakes = `-- name: GetActiveStocktakes :many
SELECT st.stocktake_id, st.stocktake_number, st.warehouse_id, st.start_date, st.end_date, st.status, st.notes, st.created_by, st.created_at, w.name as warehouse_name
FROM stock_takes st
JOIN warehouses w ON st.warehouse_id = w.warehouse_id
WHERE st.status IN ('planned', 'in_progress')
ORDER BY st.start_date ASC
`

type GetActiveStocktakesRow struct {
	StocktakeID     int32           `json:"stocktake_id"`
	StocktakeNumber string          `json:"stocktake_number"`
	WarehouseID     int32           `json:"warehouse_id"`
	StartDate       time.Time       `json:"start_date"`
	EndDate         time.Time       `json:"end_date"`
	Status          StocktakeStatus `json:"status"`
	Notes           sql.NullString  `json:"notes"`
	CreatedBy       sql.NullInt32   `json:"created_by"`
	CreatedAt       time.Time       `json:"created_at"`
	WarehouseName   string          `json:"warehouse_name"`
}

func (q *Queries) GetActiveStocktakes(ctx context.Context) ([]GetActiveStocktakesRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveStocktakes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveStocktakesRow
	for rows.Next() {
		var i GetActiveStocktakesRow
		if err := rows.Scan(
			&i.StocktakeID,
			&i.StocktakeNumber,
			&i.WarehouseID,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStocktake = `-- name: GetStocktake :one
SELECT st.stocktake_id, st.stocktake_number, st.warehouse_id, st.start_date, st.end_date, st.status, st.notes, st.created_by, st.created_at, w.name as warehouse_name
FROM stock_takes st
JOIN warehouses w ON st.warehouse_id = w.warehouse_id
WHERE st.stocktake_id = $1
`

type GetStocktakeRow struct {
	StocktakeID     int32           `json:"stocktake_id"`
	StocktakeNumber string          `json:"stocktake_number"`
	WarehouseID     int32           `json:"warehouse_id"`
	StartDate       time.Time       `json:"start_date"`
	EndDate         time.Time       `json:"end_date"`
	Status          StocktakeStatus `json:"status"`
	Notes           sql.NullString  `json:"notes"`
	CreatedBy       sql.NullInt32   `json:"created_by"`
	CreatedAt       time.Time       `json:"created_at"`
	WarehouseName   string          `json:"warehouse_name"`
}

func (q *Queries) GetStocktake(ctx context.Context, stocktakeID int32) (GetStocktakeRow, error) {
	row := q.db.QueryRowContext(ctx, getStocktake, stocktakeID)
	var i GetStocktakeRow
	err := row.Scan(
		&i.StocktakeID,
		&i.StocktakeNumber,
		&i.WarehouseID,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.WarehouseName,
	)
	return i, err
}

const getStocktakeItems = `-- name: GetStocktakeItems :many
SELECT si.stocktake_item_id, si.stocktake_id, si.product_id, si.location_id, si.system_quantity, si.counted_quantity, si.variance, si.counted_by, si.counted_at, si.notes, p.name as product_name, p.sku, l.location_code
FROM stocktake_items si
JOIN products p ON si.product_id = p.product_id
LEFT JOIN locations l ON si.location_id = l.location_id
WHERE si.stocktake_id = $1
ORDER BY p.name
`

type GetStocktakeItemsRow struct {
	StocktakeItemID int32          `json:"stocktake_item_id"`
	StocktakeID     int32          `json:"stocktake_id"`
	ProductID       int32          `json:"product_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	SystemQuantity  int32          `json:"system_quantity"`
	CountedQuantity sql.NullInt32  `json:"counted_quantity"`
	Variance        sql.NullInt32  `json:"variance"`
	CountedBy       sql.NullInt32  `json:"counted_by"`
	CountedAt       time.Time      `json:"counted_at"`
	Notes           sql.NullString `json:"notes"`
	ProductName     string         `json:"product_name"`
	Sku             string         `json:"sku"`
	LocationCode    sql.NullString `json:"location_code"`
}

func (q *Queries) GetStocktakeItems(ctx context.Context, stocktakeID int32) ([]GetStocktakeItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStocktakeItems, stocktakeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStocktakeItemsRow
	for rows.Next() {
		var i GetStocktakeItemsRow
		if err := rows.Scan(
			&i.StocktakeItemID,
			&i.StocktakeID,
			&i.ProductID,
			&i.LocationID,
			&i.SystemQuantity,
			&i.CountedQuantity,
			&i.Variance,
			&i.CountedBy,
			&i.CountedAt,
			&i.Notes,
			&i.ProductName,
			&i.Sku,
			&i.LocationCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStocktakeVariances = `-- name: GetStocktakeVariances :many
SELECT si.stocktake_item_id, si.stocktake_id, si.product_id, si.location_id, si.system_quantity, si.counted_quantity, si.variance, si.counted_by, si.counted_at, si.notes, p.name as product_name, p.sku, l.location_code
FROM stocktake_items si
JOIN products p ON si.product_id = p.product_id
LEFT JOIN locations l ON si.location_id = l.location_id
WHERE si.stocktake_id = $1
  AND si.variance != 0
ORDER BY ABS(si.variance) DESC
`

type GetStocktakeVariancesRow struct {
	StocktakeItemID int32          `json:"stocktake_item_id"`
	StocktakeID     int32          `json:"stocktake_id"`
	ProductID       int32          `json:"product_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	SystemQuantity  int32          `json:"system_quantity"`
	CountedQuantity sql.NullInt32  `json:"counted_quantity"`
	Variance        sql.NullInt32  `json:"variance"`
	CountedBy       sql.NullInt32  `json:"counted_by"`
	CountedAt       time.Time      `json:"counted_at"`
	Notes           sql.NullString `json:"notes"`
	ProductName     string         `json:"product_name"`
	Sku             string         `json:"sku"`
	LocationCode    sql.NullString `json:"location_code"`
}

func (q *Queries) GetStocktakeVariances(ctx context.Context, stocktakeID int32) ([]GetStocktakeVariancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStocktakeVariances, stocktakeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStocktakeVariancesRow
	for rows.Next() {
		var i GetStocktakeVariancesRow
		if err := rows.Scan(
			&i.StocktakeItemID,
			&i.StocktakeID,
			&i.ProductID,
			&i.LocationID,
			&i.SystemQuantity,
			&i.CountedQuantity,
			&i.Variance,
			&i.CountedBy,
			&i.CountedAt,
			&i.Notes,
			&i.ProductName,
			&i.Sku,
			&i.LocationCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStocktakes = `-- name: ListStocktakes :many
SELECT st.stocktake_id, st.stocktake_number, st.warehouse_id, st.start_date, st.end_date, st.status, st.notes, st.created_by, st.created_at, w.name as warehouse_name
FROM stock_takes st
JOIN warehouses w ON st.warehouse_id = w.warehouse_id
ORDER BY st.created_at DESC
LIMIT $1 OFFSET $2
`

type ListStocktakesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListStocktakesRow struct {
	StocktakeID     int32           `json:"stocktake_id"`
	StocktakeNumber string          `json:"stocktake_number"`
	WarehouseID     int32           `json:"warehouse_id"`
	StartDate       time.Time       `json:"start_date"`
	EndDate         time.Time       `json:"end_date"`
	Status          StocktakeStatus `json:"status"`
	Notes           sql.NullString  `json:"notes"`
	CreatedBy       sql.NullInt32   `json:"created_by"`
	CreatedAt       time.Time       `json:"created_at"`
	WarehouseName   string          `json:"warehouse_name"`
}

func (q *Queries) ListStocktakes(ctx context.Context, arg ListStocktakesParams) ([]ListStocktakesRow, error) {
	rows, err := q.db.QueryContext(ctx, listStocktakes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStocktakesRow
	for rows.Next() {
		var i ListStocktakesRow
		if err := rows.Scan(
			&i.StocktakeID,
			&i.StocktakeNumber,
			&i.WarehouseID,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStocktakesByWarehouse = `-- name: ListStocktakesByWarehouse :many
SELECT stocktake_id, stocktake_number, warehouse_id, start_date, end_date, status, notes, created_by, created_at FROM stock_takes
WHERE warehouse_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListStocktakesByWarehouse(ctx context.Context, warehouseID int32) ([]StockTake, error) {
	rows, err := q.db.QueryContext(ctx, listStocktakesByWarehouse, warehouseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockTake
	for rows.Next() {
		var i StockTake
		if err := rows.Scan(
			&i.StocktakeID,
			&i.StocktakeNumber,
			&i.WarehouseID,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStocktakeItemCount = `-- name: UpdateStocktakeItemCount :one
UPDATE stocktake_items
SET counted_quantity = $2,
    variance = $2 - system_quantity,
    counted_by = $3,
    counted_at = CURRENT_TIMESTAMP
WHERE stocktake_item_id = $1
RETURNING stocktake_item_id, stocktake_id, product_id, location_id, system_quantity, counted_quantity, variance, counted_by, counted_at, notes
`

type UpdateStocktakeItemCountParams struct {
	StocktakeItemID int32         `json:"stocktake_item_id"`
	CountedQuantity sql.NullInt32 `json:"counted_quantity"`
	CountedBy       sql.NullInt32 `json:"counted_by"`
}

func (q *Queries) UpdateStocktakeItemCount(ctx context.Context, arg UpdateStocktakeItemCountParams) (StocktakeItem, error) {
	row := q.db.QueryRowContext(ctx, updateStocktakeItemCount, arg.StocktakeItemID, arg.CountedQuantity, arg.CountedBy)
	var i StocktakeItem
	err := row.Scan(
		&i.StocktakeItemID,
		&i.StocktakeID,
		&i.ProductID,
		&i.LocationID,
		&i.SystemQuantity,
		&i.CountedQuantity,
		&i.Variance,
		&i.CountedBy,
		&i.CountedAt,
		&i.Notes,
	)
	return i, err
}

const updateStocktakeStatus = `-- name: UpdateStocktakeStatus :one
UPDATE stock_takes
SET status = $2
WHERE stocktake_id = $1
RETURNING stocktake_id, stocktake_number, warehouse_id, start_date, end_date, status, notes, created_by, created_at
`

type UpdateStocktakeStatusParams struct {
	StocktakeID int32           `json:"stocktake_id"`
	Status      StocktakeStatus `json:"status"`
}

func (q *Queries) UpdateStocktakeStatus(ctx context.Context, arg UpdateStocktakeStatusParams) (StockTake, error) {
	row := q.db.QueryRowContext(ctx, updateStocktakeStatus, arg.StocktakeID, arg.Status)
	var i StockTake
	err := row.Scan(
		&i.StocktakeID,
		&i.StocktakeNumber,
		&i.WarehouseID,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}
