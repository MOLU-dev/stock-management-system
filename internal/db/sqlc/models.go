// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

type AbcCategory string

const (
	AbcCategoryA AbcCategory = "A"
	AbcCategoryB AbcCategory = "B"
	AbcCategoryC AbcCategory = "C"
)

func (e *AbcCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AbcCategory(s)
	case string:
		*e = AbcCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for AbcCategory: %T", src)
	}
	return nil
}

type NullAbcCategory struct {
	AbcCategory AbcCategory `json:"abc_category"`
	Valid       bool        `json:"valid"` // Valid is true if AbcCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAbcCategory) Scan(value interface{}) error {
	if value == nil {
		ns.AbcCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AbcCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAbcCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AbcCategory), nil
}

func (e AbcCategory) Valid() bool {
	switch e {
	case AbcCategoryA,
		AbcCategoryB,
		AbcCategoryC:
		return true
	}
	return false
}

func AllAbcCategoryValues() []AbcCategory {
	return []AbcCategory{
		AbcCategoryA,
		AbcCategoryB,
		AbcCategoryC,
	}
}

type AbcCriteria string

const (
	AbcCriteriaValue  AbcCriteria = "value"
	AbcCriteriaVolume AbcCriteria = "volume"
	AbcCriteriaProfit AbcCriteria = "profit"
)

func (e *AbcCriteria) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AbcCriteria(s)
	case string:
		*e = AbcCriteria(s)
	default:
		return fmt.Errorf("unsupported scan type for AbcCriteria: %T", src)
	}
	return nil
}

type NullAbcCriteria struct {
	AbcCriteria AbcCriteria `json:"abc_criteria"`
	Valid       bool        `json:"valid"` // Valid is true if AbcCriteria is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAbcCriteria) Scan(value interface{}) error {
	if value == nil {
		ns.AbcCriteria, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AbcCriteria.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAbcCriteria) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AbcCriteria), nil
}

func (e AbcCriteria) Valid() bool {
	switch e {
	case AbcCriteriaValue,
		AbcCriteriaVolume,
		AbcCriteriaProfit:
		return true
	}
	return false
}

func AllAbcCriteriaValues() []AbcCriteria {
	return []AbcCriteria{
		AbcCriteriaValue,
		AbcCriteriaVolume,
		AbcCriteriaProfit,
	}
}

type ActionType string

const (
	ActionTypeCreatePo ActionType = "create_po"
	ActionTypeTransfer ActionType = "transfer"
	ActionTypeAlert    ActionType = "alert"
)

func (e *ActionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActionType(s)
	case string:
		*e = ActionType(s)
	default:
		return fmt.Errorf("unsupported scan type for ActionType: %T", src)
	}
	return nil
}

type NullActionType struct {
	ActionType ActionType `json:"action_type"`
	Valid      bool       `json:"valid"` // Valid is true if ActionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActionType) Scan(value interface{}) error {
	if value == nil {
		ns.ActionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActionType), nil
}

func (e ActionType) Valid() bool {
	switch e {
	case ActionTypeCreatePo,
		ActionTypeTransfer,
		ActionTypeAlert:
		return true
	}
	return false
}

func AllActionTypeValues() []ActionType {
	return []ActionType{
		ActionTypeCreatePo,
		ActionTypeTransfer,
		ActionTypeAlert,
	}
}

type AdjustmentReason string

const (
	AdjustmentReasonCountDiscrepancy AdjustmentReason = "count_discrepancy"
	AdjustmentReasonDamage           AdjustmentReason = "damage"
	AdjustmentReasonTheft            AdjustmentReason = "theft"
	AdjustmentReasonExpired          AdjustmentReason = "expired"
	AdjustmentReasonSample           AdjustmentReason = "sample"
	AdjustmentReasonOther            AdjustmentReason = "other"
)

func (e *AdjustmentReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AdjustmentReason(s)
	case string:
		*e = AdjustmentReason(s)
	default:
		return fmt.Errorf("unsupported scan type for AdjustmentReason: %T", src)
	}
	return nil
}

type NullAdjustmentReason struct {
	AdjustmentReason AdjustmentReason `json:"adjustment_reason"`
	Valid            bool             `json:"valid"` // Valid is true if AdjustmentReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAdjustmentReason) Scan(value interface{}) error {
	if value == nil {
		ns.AdjustmentReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AdjustmentReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAdjustmentReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AdjustmentReason), nil
}

func (e AdjustmentReason) Valid() bool {
	switch e {
	case AdjustmentReasonCountDiscrepancy,
		AdjustmentReasonDamage,
		AdjustmentReasonTheft,
		AdjustmentReasonExpired,
		AdjustmentReasonSample,
		AdjustmentReasonOther:
		return true
	}
	return false
}

func AllAdjustmentReasonValues() []AdjustmentReason {
	return []AdjustmentReason{
		AdjustmentReasonCountDiscrepancy,
		AdjustmentReasonDamage,
		AdjustmentReasonTheft,
		AdjustmentReasonExpired,
		AdjustmentReasonSample,
		AdjustmentReasonOther,
	}
}

type AdjustmentStatus string

const (
	AdjustmentStatusPending   AdjustmentStatus = "pending"
	AdjustmentStatusApproved  AdjustmentStatus = "approved"
	AdjustmentStatusRejected  AdjustmentStatus = "rejected"
	AdjustmentStatusCompleted AdjustmentStatus = "completed"
)

func (e *AdjustmentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AdjustmentStatus(s)
	case string:
		*e = AdjustmentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for AdjustmentStatus: %T", src)
	}
	return nil
}

type NullAdjustmentStatus struct {
	AdjustmentStatus AdjustmentStatus `json:"adjustment_status"`
	Valid            bool             `json:"valid"` // Valid is true if AdjustmentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAdjustmentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.AdjustmentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AdjustmentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAdjustmentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AdjustmentStatus), nil
}

func (e AdjustmentStatus) Valid() bool {
	switch e {
	case AdjustmentStatusPending,
		AdjustmentStatusApproved,
		AdjustmentStatusRejected,
		AdjustmentStatusCompleted:
		return true
	}
	return false
}

func AllAdjustmentStatusValues() []AdjustmentStatus {
	return []AdjustmentStatus{
		AdjustmentStatusPending,
		AdjustmentStatusApproved,
		AdjustmentStatusRejected,
		AdjustmentStatusCompleted,
	}
}

type AuditAction string

const (
	AuditActionINSERT AuditAction = "INSERT"
	AuditActionUPDATE AuditAction = "UPDATE"
	AuditActionDELETE AuditAction = "DELETE"
)

func (e *AuditAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditAction(s)
	case string:
		*e = AuditAction(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditAction: %T", src)
	}
	return nil
}

type NullAuditAction struct {
	AuditAction AuditAction `json:"audit_action"`
	Valid       bool        `json:"valid"` // Valid is true if AuditAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditAction) Scan(value interface{}) error {
	if value == nil {
		ns.AuditAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditAction), nil
}

func (e AuditAction) Valid() bool {
	switch e {
	case AuditActionINSERT,
		AuditActionUPDATE,
		AuditActionDELETE:
		return true
	}
	return false
}

func AllAuditActionValues() []AuditAction {
	return []AuditAction{
		AuditActionINSERT,
		AuditActionUPDATE,
		AuditActionDELETE,
	}
}

type ConditionType string

const (
	ConditionTypeStockLevel  ConditionType = "stock_level"
	ConditionTypeTimeBased   ConditionType = "time_based"
	ConditionTypeSeasonal    ConditionType = "seasonal"
	ConditionTypeDemandSpike ConditionType = "demand_spike"
)

func (e *ConditionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ConditionType(s)
	case string:
		*e = ConditionType(s)
	default:
		return fmt.Errorf("unsupported scan type for ConditionType: %T", src)
	}
	return nil
}

type NullConditionType struct {
	ConditionType ConditionType `json:"condition_type"`
	Valid         bool          `json:"valid"` // Valid is true if ConditionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullConditionType) Scan(value interface{}) error {
	if value == nil {
		ns.ConditionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ConditionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullConditionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ConditionType), nil
}

func (e ConditionType) Valid() bool {
	switch e {
	case ConditionTypeStockLevel,
		ConditionTypeTimeBased,
		ConditionTypeSeasonal,
		ConditionTypeDemandSpike:
		return true
	}
	return false
}

func AllConditionTypeValues() []ConditionType {
	return []ConditionType{
		ConditionTypeStockLevel,
		ConditionTypeTimeBased,
		ConditionTypeSeasonal,
		ConditionTypeDemandSpike,
	}
}

type CountingMethod string

const (
	CountingMethodABC           CountingMethod = "ABC"
	CountingMethodRandom        CountingMethod = "random"
	CountingMethodLocationBased CountingMethod = "location_based"
)

func (e *CountingMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CountingMethod(s)
	case string:
		*e = CountingMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for CountingMethod: %T", src)
	}
	return nil
}

type NullCountingMethod struct {
	CountingMethod CountingMethod `json:"counting_method"`
	Valid          bool           `json:"valid"` // Valid is true if CountingMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCountingMethod) Scan(value interface{}) error {
	if value == nil {
		ns.CountingMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CountingMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCountingMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CountingMethod), nil
}

func (e CountingMethod) Valid() bool {
	switch e {
	case CountingMethodABC,
		CountingMethodRandom,
		CountingMethodLocationBased:
		return true
	}
	return false
}

func AllCountingMethodValues() []CountingMethod {
	return []CountingMethod{
		CountingMethodABC,
		CountingMethodRandom,
		CountingMethodLocationBased,
	}
}

type IdentifierStatus string

const (
	IdentifierStatusActive    IdentifierStatus = "active"
	IdentifierStatusInTransit IdentifierStatus = "in_transit"
	IdentifierStatusSold      IdentifierStatus = "sold"
	IdentifierStatusReturned  IdentifierStatus = "returned"
	IdentifierStatusDamaged   IdentifierStatus = "damaged"
)

func (e *IdentifierStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IdentifierStatus(s)
	case string:
		*e = IdentifierStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for IdentifierStatus: %T", src)
	}
	return nil
}

type NullIdentifierStatus struct {
	IdentifierStatus IdentifierStatus `json:"identifier_status"`
	Valid            bool             `json:"valid"` // Valid is true if IdentifierStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIdentifierStatus) Scan(value interface{}) error {
	if value == nil {
		ns.IdentifierStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IdentifierStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIdentifierStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IdentifierStatus), nil
}

func (e IdentifierStatus) Valid() bool {
	switch e {
	case IdentifierStatusActive,
		IdentifierStatusInTransit,
		IdentifierStatusSold,
		IdentifierStatusReturned,
		IdentifierStatusDamaged:
		return true
	}
	return false
}

func AllIdentifierStatusValues() []IdentifierStatus {
	return []IdentifierStatus{
		IdentifierStatusActive,
		IdentifierStatusInTransit,
		IdentifierStatusSold,
		IdentifierStatusReturned,
		IdentifierStatusDamaged,
	}
}

type IdentifierType string

const (
	IdentifierTypeSerial IdentifierType = "serial"
	IdentifierTypeBatch  IdentifierType = "batch"
	IdentifierTypeLot    IdentifierType = "lot"
	IdentifierTypeRfid   IdentifierType = "rfid"
	IdentifierTypeQrCode IdentifierType = "qr_code"
)

func (e *IdentifierType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IdentifierType(s)
	case string:
		*e = IdentifierType(s)
	default:
		return fmt.Errorf("unsupported scan type for IdentifierType: %T", src)
	}
	return nil
}

type NullIdentifierType struct {
	IdentifierType IdentifierType `json:"identifier_type"`
	Valid          bool           `json:"valid"` // Valid is true if IdentifierType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIdentifierType) Scan(value interface{}) error {
	if value == nil {
		ns.IdentifierType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IdentifierType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIdentifierType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IdentifierType), nil
}

func (e IdentifierType) Valid() bool {
	switch e {
	case IdentifierTypeSerial,
		IdentifierTypeBatch,
		IdentifierTypeLot,
		IdentifierTypeRfid,
		IdentifierTypeQrCode:
		return true
	}
	return false
}

func AllIdentifierTypeValues() []IdentifierType {
	return []IdentifierType{
		IdentifierTypeSerial,
		IdentifierTypeBatch,
		IdentifierTypeLot,
		IdentifierTypeRfid,
		IdentifierTypeQrCode,
	}
}

type IncidentType string

const (
	IncidentTypeTheft      IncidentType = "theft"
	IncidentTypeDamage     IncidentType = "damage"
	IncidentTypeMiscount   IncidentType = "miscount"
	IncidentTypeExpiration IncidentType = "expiration"
	IncidentTypeUnknown    IncidentType = "unknown"
)

func (e *IncidentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IncidentType(s)
	case string:
		*e = IncidentType(s)
	default:
		return fmt.Errorf("unsupported scan type for IncidentType: %T", src)
	}
	return nil
}

type NullIncidentType struct {
	IncidentType IncidentType `json:"incident_type"`
	Valid        bool         `json:"valid"` // Valid is true if IncidentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIncidentType) Scan(value interface{}) error {
	if value == nil {
		ns.IncidentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IncidentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIncidentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IncidentType), nil
}

func (e IncidentType) Valid() bool {
	switch e {
	case IncidentTypeTheft,
		IncidentTypeDamage,
		IncidentTypeMiscount,
		IncidentTypeExpiration,
		IncidentTypeUnknown:
		return true
	}
	return false
}

func AllIncidentTypeValues() []IncidentType {
	return []IncidentType{
		IncidentTypeTheft,
		IncidentTypeDamage,
		IncidentTypeMiscount,
		IncidentTypeExpiration,
		IncidentTypeUnknown,
	}
}

type InventoryStatus string

const (
	InventoryStatusInStock  InventoryStatus = "in_stock"
	InventoryStatusReserved InventoryStatus = "reserved"
	InventoryStatusShipped  InventoryStatus = "shipped"
	InventoryStatusReturned InventoryStatus = "returned"
	InventoryStatusDamaged  InventoryStatus = "damaged"
)

func (e *InventoryStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InventoryStatus(s)
	case string:
		*e = InventoryStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InventoryStatus: %T", src)
	}
	return nil
}

type NullInventoryStatus struct {
	InventoryStatus InventoryStatus `json:"inventory_status"`
	Valid           bool            `json:"valid"` // Valid is true if InventoryStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInventoryStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InventoryStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InventoryStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInventoryStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InventoryStatus), nil
}

func (e InventoryStatus) Valid() bool {
	switch e {
	case InventoryStatusInStock,
		InventoryStatusReserved,
		InventoryStatusShipped,
		InventoryStatusReturned,
		InventoryStatusDamaged:
		return true
	}
	return false
}

func AllInventoryStatusValues() []InventoryStatus {
	return []InventoryStatus{
		InventoryStatusInStock,
		InventoryStatusReserved,
		InventoryStatusShipped,
		InventoryStatusReturned,
		InventoryStatusDamaged,
	}
}

type LocationMovementType string

const (
	LocationMovementTypePick       LocationMovementType = "pick"
	LocationMovementTypePutaway    LocationMovementType = "putaway"
	LocationMovementTypeTransfer   LocationMovementType = "transfer"
	LocationMovementTypeAdjustment LocationMovementType = "adjustment"
)

func (e *LocationMovementType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LocationMovementType(s)
	case string:
		*e = LocationMovementType(s)
	default:
		return fmt.Errorf("unsupported scan type for LocationMovementType: %T", src)
	}
	return nil
}

type NullLocationMovementType struct {
	LocationMovementType LocationMovementType `json:"location_movement_type"`
	Valid                bool                 `json:"valid"` // Valid is true if LocationMovementType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLocationMovementType) Scan(value interface{}) error {
	if value == nil {
		ns.LocationMovementType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LocationMovementType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLocationMovementType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LocationMovementType), nil
}

func (e LocationMovementType) Valid() bool {
	switch e {
	case LocationMovementTypePick,
		LocationMovementTypePutaway,
		LocationMovementTypeTransfer,
		LocationMovementTypeAdjustment:
		return true
	}
	return false
}

func AllLocationMovementTypeValues() []LocationMovementType {
	return []LocationMovementType{
		LocationMovementTypePick,
		LocationMovementTypePutaway,
		LocationMovementTypeTransfer,
		LocationMovementTypeAdjustment,
	}
}

type MovementType string

const (
	MovementTypePurchaseReceipt MovementType = "purchase_receipt"
	MovementTypeSalesDelivery   MovementType = "sales_delivery"
	MovementTypeStockTransfer   MovementType = "stock_transfer"
	MovementTypeStockAdjustment MovementType = "stock_adjustment"
	MovementTypeReturn          MovementType = "return"
	MovementTypeDamage          MovementType = "damage"
	MovementTypeProduction      MovementType = "production"
)

func (e *MovementType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MovementType(s)
	case string:
		*e = MovementType(s)
	default:
		return fmt.Errorf("unsupported scan type for MovementType: %T", src)
	}
	return nil
}

type NullMovementType struct {
	MovementType MovementType `json:"movement_type"`
	Valid        bool         `json:"valid"` // Valid is true if MovementType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMovementType) Scan(value interface{}) error {
	if value == nil {
		ns.MovementType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MovementType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMovementType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MovementType), nil
}

func (e MovementType) Valid() bool {
	switch e {
	case MovementTypePurchaseReceipt,
		MovementTypeSalesDelivery,
		MovementTypeStockTransfer,
		MovementTypeStockAdjustment,
		MovementTypeReturn,
		MovementTypeDamage,
		MovementTypeProduction:
		return true
	}
	return false
}

func AllMovementTypeValues() []MovementType {
	return []MovementType{
		MovementTypePurchaseReceipt,
		MovementTypeSalesDelivery,
		MovementTypeStockTransfer,
		MovementTypeStockAdjustment,
		MovementTypeReturn,
		MovementTypeDamage,
		MovementTypeProduction,
	}
}

type PurchaseOrderStatus string

const (
	PurchaseOrderStatusDraft             PurchaseOrderStatus = "draft"
	PurchaseOrderStatusPending           PurchaseOrderStatus = "pending"
	PurchaseOrderStatusApproved          PurchaseOrderStatus = "approved"
	PurchaseOrderStatusPartiallyReceived PurchaseOrderStatus = "partially_received"
	PurchaseOrderStatusCompleted         PurchaseOrderStatus = "completed"
	PurchaseOrderStatusCancelled         PurchaseOrderStatus = "cancelled"
)

func (e *PurchaseOrderStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PurchaseOrderStatus(s)
	case string:
		*e = PurchaseOrderStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PurchaseOrderStatus: %T", src)
	}
	return nil
}

type NullPurchaseOrderStatus struct {
	PurchaseOrderStatus PurchaseOrderStatus `json:"purchase_order_status"`
	Valid               bool                `json:"valid"` // Valid is true if PurchaseOrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPurchaseOrderStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PurchaseOrderStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PurchaseOrderStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPurchaseOrderStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PurchaseOrderStatus), nil
}

func (e PurchaseOrderStatus) Valid() bool {
	switch e {
	case PurchaseOrderStatusDraft,
		PurchaseOrderStatusPending,
		PurchaseOrderStatusApproved,
		PurchaseOrderStatusPartiallyReceived,
		PurchaseOrderStatusCompleted,
		PurchaseOrderStatusCancelled:
		return true
	}
	return false
}

func AllPurchaseOrderStatusValues() []PurchaseOrderStatus {
	return []PurchaseOrderStatus{
		PurchaseOrderStatusDraft,
		PurchaseOrderStatusPending,
		PurchaseOrderStatusApproved,
		PurchaseOrderStatusPartiallyReceived,
		PurchaseOrderStatusCompleted,
		PurchaseOrderStatusCancelled,
	}
}

type ReconciliationFrequency string

const (
	ReconciliationFrequencyDaily     ReconciliationFrequency = "daily"
	ReconciliationFrequencyWeekly    ReconciliationFrequency = "weekly"
	ReconciliationFrequencyMonthly   ReconciliationFrequency = "monthly"
	ReconciliationFrequencyQuarterly ReconciliationFrequency = "quarterly"
)

func (e *ReconciliationFrequency) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReconciliationFrequency(s)
	case string:
		*e = ReconciliationFrequency(s)
	default:
		return fmt.Errorf("unsupported scan type for ReconciliationFrequency: %T", src)
	}
	return nil
}

type NullReconciliationFrequency struct {
	ReconciliationFrequency ReconciliationFrequency `json:"reconciliation_frequency"`
	Valid                   bool                    `json:"valid"` // Valid is true if ReconciliationFrequency is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReconciliationFrequency) Scan(value interface{}) error {
	if value == nil {
		ns.ReconciliationFrequency, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReconciliationFrequency.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReconciliationFrequency) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReconciliationFrequency), nil
}

func (e ReconciliationFrequency) Valid() bool {
	switch e {
	case ReconciliationFrequencyDaily,
		ReconciliationFrequencyWeekly,
		ReconciliationFrequencyMonthly,
		ReconciliationFrequencyQuarterly:
		return true
	}
	return false
}

func AllReconciliationFrequencyValues() []ReconciliationFrequency {
	return []ReconciliationFrequency{
		ReconciliationFrequencyDaily,
		ReconciliationFrequencyWeekly,
		ReconciliationFrequencyMonthly,
		ReconciliationFrequencyQuarterly,
	}
}

type StocktakeStatus string

const (
	StocktakeStatusPlanned    StocktakeStatus = "planned"
	StocktakeStatusInProgress StocktakeStatus = "in_progress"
	StocktakeStatusCompleted  StocktakeStatus = "completed"
	StocktakeStatusCancelled  StocktakeStatus = "cancelled"
)

func (e *StocktakeStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StocktakeStatus(s)
	case string:
		*e = StocktakeStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for StocktakeStatus: %T", src)
	}
	return nil
}

type NullStocktakeStatus struct {
	StocktakeStatus StocktakeStatus `json:"stocktake_status"`
	Valid           bool            `json:"valid"` // Valid is true if StocktakeStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStocktakeStatus) Scan(value interface{}) error {
	if value == nil {
		ns.StocktakeStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StocktakeStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStocktakeStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StocktakeStatus), nil
}

func (e StocktakeStatus) Valid() bool {
	switch e {
	case StocktakeStatusPlanned,
		StocktakeStatusInProgress,
		StocktakeStatusCompleted,
		StocktakeStatusCancelled:
		return true
	}
	return false
}

func AllStocktakeStatusValues() []StocktakeStatus {
	return []StocktakeStatus{
		StocktakeStatusPlanned,
		StocktakeStatusInProgress,
		StocktakeStatusCompleted,
		StocktakeStatusCancelled,
	}
}

type TransferStatus string

const (
	TransferStatusPending   TransferStatus = "pending"
	TransferStatusInTransit TransferStatus = "in_transit"
	TransferStatusCompleted TransferStatus = "completed"
	TransferStatusCancelled TransferStatus = "cancelled"
)

func (e *TransferStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransferStatus(s)
	case string:
		*e = TransferStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TransferStatus: %T", src)
	}
	return nil
}

type NullTransferStatus struct {
	TransferStatus TransferStatus `json:"transfer_status"`
	Valid          bool           `json:"valid"` // Valid is true if TransferStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransferStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TransferStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransferStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransferStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransferStatus), nil
}

func (e TransferStatus) Valid() bool {
	switch e {
	case TransferStatusPending,
		TransferStatusInTransit,
		TransferStatusCompleted,
		TransferStatusCancelled:
		return true
	}
	return false
}

func AllTransferStatusValues() []TransferStatus {
	return []TransferStatus{
		TransferStatusPending,
		TransferStatusInTransit,
		TransferStatusCompleted,
		TransferStatusCancelled,
	}
}

type UserRole string

const (
	UserRoleAdmin   UserRole = "admin"
	UserRoleManager UserRole = "manager"
	UserRoleStaff   UserRole = "staff"
	UserRoleViewer  UserRole = "viewer"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

func (e UserRole) Valid() bool {
	switch e {
	case UserRoleAdmin,
		UserRoleManager,
		UserRoleStaff,
		UserRoleViewer:
		return true
	}
	return false
}

func AllUserRoleValues() []UserRole {
	return []UserRole{
		UserRoleAdmin,
		UserRoleManager,
		UserRoleStaff,
		UserRoleViewer,
	}
}

type WaveStatus string

const (
	WaveStatusPlanned    WaveStatus = "planned"
	WaveStatusInProgress WaveStatus = "in_progress"
	WaveStatusCompleted  WaveStatus = "completed"
	WaveStatusCancelled  WaveStatus = "cancelled"
)

func (e *WaveStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WaveStatus(s)
	case string:
		*e = WaveStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for WaveStatus: %T", src)
	}
	return nil
}

type NullWaveStatus struct {
	WaveStatus WaveStatus `json:"wave_status"`
	Valid      bool       `json:"valid"` // Valid is true if WaveStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWaveStatus) Scan(value interface{}) error {
	if value == nil {
		ns.WaveStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WaveStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWaveStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WaveStatus), nil
}

func (e WaveStatus) Valid() bool {
	switch e {
	case WaveStatusPlanned,
		WaveStatusInProgress,
		WaveStatusCompleted,
		WaveStatusCancelled:
		return true
	}
	return false
}

func AllWaveStatusValues() []WaveStatus {
	return []WaveStatus{
		WaveStatusPlanned,
		WaveStatusInProgress,
		WaveStatusCompleted,
		WaveStatusCancelled,
	}
}

type AbcClassification struct {
	ClassificationID int32       `json:"classification_id"`
	ProductID        int32       `json:"product_id"`
	WarehouseID      int32       `json:"warehouse_id"`
	Category         AbcCategory `json:"category"`
	Criteria         AbcCriteria `json:"criteria"`
	Ranking          pgtype.Int4 `json:"ranking"`
	LastUpdated      time.Time   `json:"last_updated"`
}

type AuditLog struct {
	AuditID   int32       `json:"audit_id"`
	TableName string      `json:"table_name"`
	RecordID  int32       `json:"record_id"`
	Action    AuditAction `json:"action"`
	OldValues []byte      `json:"old_values"`
	NewValues []byte      `json:"new_values"`
	ChangedAt time.Time   `json:"changed_at"`
	ChangedBy pgtype.Int4 `json:"changed_by"`
}

type Category struct {
	CategoryID       int32       `json:"category_id"`
	CategoryCode     string      `json:"category_code"`
	Name             string      `json:"name"`
	ParentCategoryID pgtype.Int4 `json:"parent_category_id"`
	Description      pgtype.Text `json:"description"`
	CreatedAt        time.Time   `json:"created_at"`
}

type CycleCountSchedule struct {
	ScheduleID     int32              `json:"schedule_id"`
	WarehouseID    pgtype.Int4        `json:"warehouse_id"`
	ZoneID         pgtype.Int4        `json:"zone_id"`
	FrequencyDays  pgtype.Int4        `json:"frequency_days"`
	CountingMethod NullCountingMethod `json:"counting_method"`
	LastCounted    time.Time          `json:"last_counted"`
	NextScheduled  time.Time          `json:"next_scheduled"`
	AssignedTo     pgtype.Int4        `json:"assigned_to"`
}

type Inventory struct {
	InventoryID       int32               `json:"inventory_id"`
	ProductID         int32               `json:"product_id"`
	WarehouseID       int32               `json:"warehouse_id"`
	LocationID        pgtype.Int4         `json:"location_id"`
	Quantity          pgtype.Int4         `json:"quantity"`
	ReservedQuantity  pgtype.Int4         `json:"reserved_quantity"`
	BatchNumber       pgtype.Text         `json:"batch_number"`
	ExpiryDate        time.Time           `json:"expiry_date"`
	ManufacturingDate time.Time           `json:"manufacturing_date"`
	SerialNumber      pgtype.Text         `json:"serial_number"`
	Status            NullInventoryStatus `json:"status"`
	LastCountedDate   time.Time           `json:"last_counted_date"`
	CreatedAt         time.Time           `json:"created_at"`
	UpdatedAt         time.Time           `json:"updated_at"`
}

type InventoryForecasting struct {
	ForecastID             int32           `json:"forecast_id"`
	ProductID              int32           `json:"product_id"`
	WarehouseID            int32           `json:"warehouse_id"`
	ForecastDate           time.Time       `json:"forecast_date"`
	PredictedDemand        pgtype.Int4     `json:"predicted_demand"`
	ConfidenceLevel        decimal.Decimal `json:"confidence_level"`
	CalculatedReorderPoint pgtype.Int4     `json:"calculated_reorder_point"`
	CalculatedSafetyStock  pgtype.Int4     `json:"calculated_safety_stock"`
}

type Location struct {
	LocationID   int32       `json:"location_id"`
	WarehouseID  int32       `json:"warehouse_id"`
	LocationCode string      `json:"location_code"`
	Aisle        pgtype.Text `json:"aisle"`
	Shelf        pgtype.Text `json:"shelf"`
	Bin          pgtype.Text `json:"bin"`
	MaxCapacity  pgtype.Int4 `json:"max_capacity"`
	IsActive     pgtype.Bool `json:"is_active"`
}

type LocationHistory struct {
	HistoryID      int32                    `json:"history_id"`
	IdentifierID   int32                    `json:"identifier_id"`
	FromLocationID pgtype.Int4              `json:"from_location_id"`
	ToLocationID   pgtype.Int4              `json:"to_location_id"`
	MovementType   NullLocationMovementType `json:"movement_type"`
	ScannedBy      pgtype.Int4              `json:"scanned_by"`
	ScannedAt      time.Time                `json:"scanned_at"`
	DeviceID       pgtype.Text              `json:"device_id"`
}

type PickingRoute struct {
	RouteID     int32 `json:"route_id"`
	WarehouseID int32 `json:"warehouse_id"`
	// Array of zone IDs in optimal order
	ZoneSequence         []byte      `json:"zone_sequence"`
	EstimatedTimeMinutes pgtype.Int4 `json:"estimated_time_minutes"`
	CreatedAt            time.Time   `json:"created_at"`
}

type PickingWafe struct {
	WaveID      int32          `json:"wave_id"`
	WarehouseID int32          `json:"warehouse_id"`
	WaveNumber  pgtype.Text    `json:"wave_number"`
	Status      NullWaveStatus `json:"status"`
	Priority    pgtype.Int4    `json:"priority"`
	TotalItems  pgtype.Int4    `json:"total_items"`
	AssignedTo  pgtype.Int4    `json:"assigned_to"`
	StartTime   time.Time      `json:"start_time"`
	EndTime     time.Time      `json:"end_time"`
	CreatedAt   time.Time      `json:"created_at"`
}

type Product struct {
	ProductID       int32           `json:"product_id"`
	Sku             string          `json:"sku"`
	Name            string          `json:"name"`
	Description     pgtype.Text     `json:"description"`
	CategoryID      pgtype.Int4     `json:"category_id"`
	UnitPrice       decimal.Decimal `json:"unit_price"`
	CostPrice       decimal.Decimal `json:"cost_price"`
	Barcode         pgtype.Text     `json:"barcode"`
	Weight          decimal.Decimal `json:"weight"`
	Dimensions      pgtype.Text     `json:"dimensions"`
	SupplierID      pgtype.Int4     `json:"supplier_id"`
	MinStockLevel   pgtype.Int4     `json:"min_stock_level"`
	MaxStockLevel   pgtype.Int4     `json:"max_stock_level"`
	ReorderPoint    pgtype.Int4     `json:"reorder_point"`
	SafetyStock     pgtype.Int4     `json:"safety_stock"`
	LeadTimeDays    pgtype.Int4     `json:"lead_time_days"`
	AutoReorder     pgtype.Bool     `json:"auto_reorder"`
	LastReorderDate time.Time       `json:"last_reorder_date"`
	IsActive        pgtype.Bool     `json:"is_active"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
}

type ProductIdentifier struct {
	IdentifierID    int32                `json:"identifier_id"`
	ProductID       int32                `json:"product_id"`
	IdentifierType  IdentifierType       `json:"identifier_type"`
	IdentifierValue string               `json:"identifier_value"`
	LocationID      pgtype.Int4          `json:"location_id"`
	Status          NullIdentifierStatus `json:"status"`
	CreatedAt       time.Time            `json:"created_at"`
}

type ProductSupplier struct {
	ProductSupplierID int32 `json:"product_supplier_id"`
	ProductID         int32 `json:"product_id"`
	SupplierID        int32 `json:"supplier_id"`
	// 1 = primary, 2 = secondary, etc.
	Priority          pgtype.Int4     `json:"priority"`
	LeadTimeDays      pgtype.Int4     `json:"lead_time_days"`
	UnitPrice         decimal.Decimal `json:"unit_price"`
	MinOrderQuantity  pgtype.Int4     `json:"min_order_quantity"`
	IsActive          pgtype.Bool     `json:"is_active"`
	LastOrderDate     time.Time       `json:"last_order_date"`
	PerformanceRating decimal.Decimal `json:"performance_rating"`
}

type PurchaseOrder struct {
	PoID                 int32                   `json:"po_id"`
	PoNumber             string                  `json:"po_number"`
	SupplierID           int32                   `json:"supplier_id"`
	OrderDate            time.Time               `json:"order_date"`
	ExpectedDeliveryDate time.Time               `json:"expected_delivery_date"`
	Status               NullPurchaseOrderStatus `json:"status"`
	TotalAmount          decimal.Decimal         `json:"total_amount"`
	Notes                pgtype.Text             `json:"notes"`
	CreatedBy            pgtype.Int4             `json:"created_by"`
	CreatedAt            time.Time               `json:"created_at"`
}

type PurchaseOrderItem struct {
	PoItemID         int32           `json:"po_item_id"`
	PoID             int32           `json:"po_id"`
	ProductID        int32           `json:"product_id"`
	QuantityOrdered  int32           `json:"quantity_ordered"`
	QuantityReceived pgtype.Int4     `json:"quantity_received"`
	UnitPrice        decimal.Decimal `json:"unit_price"`
	// Generated: quantity_ordered * unit_price
	TotalPrice decimal.Decimal `json:"total_price"`
}

type ReconciliationRule struct {
	RuleID                  int32                       `json:"rule_id"`
	WarehouseID             pgtype.Int4                 `json:"warehouse_id"`
	ProductCategoryID       pgtype.Int4                 `json:"product_category_id"`
	ReconciliationFrequency NullReconciliationFrequency `json:"reconciliation_frequency"`
	VarianceThreshold       decimal.Decimal             `json:"variance_threshold"`
	AutoAdjust              pgtype.Bool                 `json:"auto_adjust"`
	// Array of user IDs to notify
	NotifyUsers []byte    `json:"notify_users"`
	CreatedAt   time.Time `json:"created_at"`
}

type ReorderRule struct {
	RuleID           int32             `json:"rule_id"`
	RuleName         string            `json:"rule_name"`
	ProductID        pgtype.Int4       `json:"product_id"`
	CategoryID       pgtype.Int4       `json:"category_id"`
	SupplierID       pgtype.Int4       `json:"supplier_id"`
	ConditionType    NullConditionType `json:"condition_type"`
	ConditionValue   []byte            `json:"condition_value"`
	ActionType       NullActionType    `json:"action_type"`
	ActionParameters []byte            `json:"action_parameters"`
	IsActive         pgtype.Bool       `json:"is_active"`
	CreatedAt        time.Time         `json:"created_at"`
}

type ShrinkageIncident struct {
	IncidentID      int32           `json:"incident_id"`
	WarehouseID     int32           `json:"warehouse_id"`
	IncidentDate    time.Time       `json:"incident_date"`
	IncidentType    IncidentType    `json:"incident_type"`
	EstimatedValue  decimal.Decimal `json:"estimated_value"`
	DetectedBy      pgtype.Int4     `json:"detected_by"`
	Resolved        pgtype.Bool     `json:"resolved"`
	ResolutionNotes pgtype.Text     `json:"resolution_notes"`
	CreatedAt       time.Time       `json:"created_at"`
}

type StockAdjustment struct {
	AdjustmentID     int32                `json:"adjustment_id"`
	AdjustmentNumber string               `json:"adjustment_number"`
	WarehouseID      int32                `json:"warehouse_id"`
	AdjustmentDate   time.Time            `json:"adjustment_date"`
	Reason           AdjustmentReason     `json:"reason"`
	Status           NullAdjustmentStatus `json:"status"`
	TotalValue       decimal.Decimal      `json:"total_value"`
	Notes            pgtype.Text          `json:"notes"`
	ApprovedBy       pgtype.Int4          `json:"approved_by"`
	ApprovedAt       time.Time            `json:"approved_at"`
	CreatedBy        pgtype.Int4          `json:"created_by"`
	CreatedAt        time.Time            `json:"created_at"`
}

type StockAdjustmentItem struct {
	AdjustmentItemID int32 `json:"adjustment_item_id"`
	AdjustmentID     int32 `json:"adjustment_id"`
	ProductID        int32 `json:"product_id"`
	QuantityBefore   int32 `json:"quantity_before"`
	QuantityAdjusted int32 `json:"quantity_adjusted"`
	// Generated: quantity_before + quantity_adjusted
	QuantityAfter pgtype.Int4     `json:"quantity_after"`
	CostPrice     decimal.Decimal `json:"cost_price"`
	// Generated: quantity_adjusted * cost_price
	AdjustmentValue decimal.Decimal `json:"adjustment_value"`
	Reason          pgtype.Text     `json:"reason"`
}

type StockMovement struct {
	MovementID      int32        `json:"movement_id"`
	ReferenceNumber pgtype.Text  `json:"reference_number"`
	ProductID       int32        `json:"product_id"`
	WarehouseID     int32        `json:"warehouse_id"`
	LocationID      pgtype.Int4  `json:"location_id"`
	MovementType    MovementType `json:"movement_type"`
	QuantityBefore  pgtype.Int4  `json:"quantity_before"`
	QuantityChange  int32        `json:"quantity_change"`
	QuantityAfter   pgtype.Int4  `json:"quantity_after"`
	ReferenceID     pgtype.Int4  `json:"reference_id"`
	ReferenceTable  pgtype.Text  `json:"reference_table"`
	Notes           pgtype.Text  `json:"notes"`
	MovementDate    time.Time    `json:"movement_date"`
	CreatedBy       pgtype.Int4  `json:"created_by"`
}

type StockTake struct {
	StocktakeID     int32               `json:"stocktake_id"`
	StocktakeNumber string              `json:"stocktake_number"`
	WarehouseID     int32               `json:"warehouse_id"`
	StartDate       time.Time           `json:"start_date"`
	EndDate         time.Time           `json:"end_date"`
	Status          NullStocktakeStatus `json:"status"`
	Notes           pgtype.Text         `json:"notes"`
	CreatedBy       pgtype.Int4         `json:"created_by"`
	CreatedAt       time.Time           `json:"created_at"`
}

type StockTransfer struct {
	TransferID             int32              `json:"transfer_id"`
	TransferNumber         string             `json:"transfer_number"`
	FromWarehouseID        int32              `json:"from_warehouse_id"`
	ToWarehouseID          int32              `json:"to_warehouse_id"`
	Status                 NullTransferStatus `json:"status"`
	TransferDate           time.Time          `json:"transfer_date"`
	ExpectedCompletionDate time.Time          `json:"expected_completion_date"`
	Notes                  pgtype.Text        `json:"notes"`
	CreatedBy              pgtype.Int4        `json:"created_by"`
	CreatedAt              time.Time          `json:"created_at"`
}

type StockTransferItem struct {
	TransferItemID   int32       `json:"transfer_item_id"`
	TransferID       int32       `json:"transfer_id"`
	ProductID        int32       `json:"product_id"`
	Quantity         int32       `json:"quantity"`
	QuantitySent     pgtype.Int4 `json:"quantity_sent"`
	QuantityReceived pgtype.Int4 `json:"quantity_received"`
	FromLocationID   pgtype.Int4 `json:"from_location_id"`
	ToLocationID     pgtype.Int4 `json:"to_location_id"`
}

type StocktakeItem struct {
	StocktakeItemID int32       `json:"stocktake_item_id"`
	StocktakeID     int32       `json:"stocktake_id"`
	ProductID       int32       `json:"product_id"`
	LocationID      pgtype.Int4 `json:"location_id"`
	SystemQuantity  int32       `json:"system_quantity"`
	CountedQuantity pgtype.Int4 `json:"counted_quantity"`
	// Generated: counted_quantity - system_quantity
	Variance  pgtype.Int4 `json:"variance"`
	CountedBy pgtype.Int4 `json:"counted_by"`
	CountedAt time.Time   `json:"counted_at"`
	Notes     pgtype.Text `json:"notes"`
}

type Supplier struct {
	SupplierID    int32           `json:"supplier_id"`
	Code          string          `json:"code"`
	Name          string          `json:"name"`
	ContactPerson pgtype.Text     `json:"contact_person"`
	Email         pgtype.Text     `json:"email"`
	Phone         pgtype.Text     `json:"phone"`
	Address       pgtype.Text     `json:"address"`
	TaxID         pgtype.Text     `json:"tax_id"`
	PaymentTerms  pgtype.Text     `json:"payment_terms"`
	LeadTimeDays  pgtype.Int4     `json:"lead_time_days"`
	Rating        decimal.Decimal `json:"rating"`
	IsActive      pgtype.Bool     `json:"is_active"`
	CreatedAt     time.Time       `json:"created_at"`
}

type UnitsOfMeasure struct {
	UomID       int32       `json:"uom_id"`
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

type User struct {
	UserID       int32        `json:"user_id"`
	Username     string       `json:"username"`
	Email        string       `json:"email"`
	PasswordHash string       `json:"password_hash"`
	FullName     string       `json:"full_name"`
	Role         NullUserRole `json:"role"`
	WarehouseID  pgtype.Int4  `json:"warehouse_id"`
	IsActive     pgtype.Bool  `json:"is_active"`
	CreatedAt    time.Time    `json:"created_at"`
}

type Warehouse struct {
	WarehouseID   int32       `json:"warehouse_id"`
	Code          string      `json:"code"`
	Name          string      `json:"name"`
	Address       pgtype.Text `json:"address"`
	ContactPerson pgtype.Text `json:"contact_person"`
	ContactPhone  pgtype.Text `json:"contact_phone"`
	ContactEmail  pgtype.Text `json:"contact_email"`
	IsActive      pgtype.Bool `json:"is_active"`
	CreatedAt     time.Time   `json:"created_at"`
}
