// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: suppliers.sql

package db

import (
	"context"
	"database/sql"

	"github.com/shopspring/decimal"
)

const activateSupplier = `-- name: ActivateSupplier :exec
UPDATE suppliers 
SET is_active = true 
WHERE supplier_id = $1
`

func (q *Queries) ActivateSupplier(ctx context.Context, supplierID int32) error {
	_, err := q.db.ExecContext(ctx, activateSupplier, supplierID)
	return err
}

const createSupplier = `-- name: CreateSupplier :one
INSERT INTO suppliers (
    code, name, contact_person, email, phone, address, 
    tax_id, payment_terms, lead_time_days, rating, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at
`

type CreateSupplierParams struct {
	Code          string          `json:"code"`
	Name          string          `json:"name"`
	ContactPerson sql.NullString  `json:"contact_person"`
	Email         sql.NullString  `json:"email"`
	Phone         sql.NullString  `json:"phone"`
	Address       sql.NullString  `json:"address"`
	TaxID         sql.NullString  `json:"tax_id"`
	PaymentTerms  sql.NullString  `json:"payment_terms"`
	LeadTimeDays  sql.NullInt32   `json:"lead_time_days"`
	Rating        decimal.Decimal `json:"rating"`
	IsActive      bool            `json:"is_active"`
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, createSupplier,
		arg.Code,
		arg.Name,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.TaxID,
		arg.PaymentTerms,
		arg.LeadTimeDays,
		arg.Rating,
		arg.IsActive,
	)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.Code,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.TaxID,
		&i.PaymentTerms,
		&i.LeadTimeDays,
		&i.Rating,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateSupplier = `-- name: DeactivateSupplier :exec
UPDATE suppliers 
SET is_active = false 
WHERE supplier_id = $1
`

func (q *Queries) DeactivateSupplier(ctx context.Context, supplierID int32) error {
	_, err := q.db.ExecContext(ctx, deactivateSupplier, supplierID)
	return err
}

const getSupplier = `-- name: GetSupplier :one
SELECT supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at FROM suppliers 
WHERE supplier_id = $1
`

func (q *Queries) GetSupplier(ctx context.Context, supplierID int32) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, getSupplier, supplierID)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.Code,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.TaxID,
		&i.PaymentTerms,
		&i.LeadTimeDays,
		&i.Rating,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getSupplierByCode = `-- name: GetSupplierByCode :one
SELECT supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at FROM suppliers 
WHERE code = $1
`

func (q *Queries) GetSupplierByCode(ctx context.Context, code string) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, getSupplierByCode, code)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.Code,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.TaxID,
		&i.PaymentTerms,
		&i.LeadTimeDays,
		&i.Rating,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getSupplierPerformance = `-- name: GetSupplierPerformance :one
SELECT 
    COUNT(DISTINCT po.po_id) as total_orders,
    COUNT(DISTINCT po.product_id) as unique_products,
    AVG(po.unit_price) as avg_unit_price,
    MAX(po.order_date) as last_order_date
FROM purchase_order_items po
INNER JOIN purchase_orders p ON po.po_id = p.po_id
WHERE p.supplier_id = $1
`

type GetSupplierPerformanceRow struct {
	TotalOrders    int64       `json:"total_orders"`
	UniqueProducts int64       `json:"unique_products"`
	AvgUnitPrice   float64     `json:"avg_unit_price"`
	LastOrderDate  interface{} `json:"last_order_date"`
}

func (q *Queries) GetSupplierPerformance(ctx context.Context, supplierID int32) (GetSupplierPerformanceRow, error) {
	row := q.db.QueryRowContext(ctx, getSupplierPerformance, supplierID)
	var i GetSupplierPerformanceRow
	err := row.Scan(
		&i.TotalOrders,
		&i.UniqueProducts,
		&i.AvgUnitPrice,
		&i.LastOrderDate,
	)
	return i, err
}

const getSupplierProducts = `-- name: GetSupplierProducts :many
SELECT p.product_id, p.sku, p.name, p.description, p.category_id, p.unit_price, p.cost_price, p.barcode, p.weight, p.dimensions, p.supplier_id, p.min_stock_level, p.max_stock_level, p.reorder_point, p.safety_stock, p.lead_time_days, p.auto_reorder, p.last_reorder_date, p.is_active, p.created_at, p.updated_at 
FROM products p
INNER JOIN product_suppliers ps ON p.product_id = ps.product_id
WHERE ps.supplier_id = $1 
    AND ps.is_active = true
ORDER BY p.name
LIMIT $2 OFFSET $3
`

type GetSupplierProductsParams struct {
	SupplierID int32 `json:"supplier_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) GetSupplierProducts(ctx context.Context, arg GetSupplierProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getSupplierProducts, arg.SupplierID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.Sku,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.UnitPrice,
			&i.CostPrice,
			&i.Barcode,
			&i.Weight,
			&i.Dimensions,
			&i.SupplierID,
			&i.MinStockLevel,
			&i.MaxStockLevel,
			&i.ReorderPoint,
			&i.SafetyStock,
			&i.LeadTimeDays,
			&i.AutoReorder,
			&i.LastReorderDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveSuppliers = `-- name: ListActiveSuppliers :many
SELECT supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at FROM suppliers 
WHERE is_active = true 
ORDER BY name
`

func (q *Queries) ListActiveSuppliers(ctx context.Context) ([]Supplier, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSuppliers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.SupplierID,
			&i.Code,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.TaxID,
			&i.PaymentTerms,
			&i.LeadTimeDays,
			&i.Rating,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllSuppliers = `-- name: ListAllSuppliers :many
SELECT supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at FROM suppliers 
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListAllSuppliersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllSuppliers(ctx context.Context, arg ListAllSuppliersParams) ([]Supplier, error) {
	rows, err := q.db.QueryContext(ctx, listAllSuppliers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.SupplierID,
			&i.Code,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.TaxID,
			&i.PaymentTerms,
			&i.LeadTimeDays,
			&i.Rating,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppliers = `-- name: ListSuppliers :many
SELECT supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at FROM suppliers 
WHERE is_active = true
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListSuppliersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSuppliers(ctx context.Context, arg ListSuppliersParams) ([]Supplier, error) {
	rows, err := q.db.QueryContext(ctx, listSuppliers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.SupplierID,
			&i.Code,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.TaxID,
			&i.PaymentTerms,
			&i.LeadTimeDays,
			&i.Rating,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSuppliers = `-- name: SearchSuppliers :many
SELECT supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at FROM suppliers 
WHERE is_active = true 
    AND (
        name ILIKE '%' || $1 || '%' 
        OR code ILIKE '%' || $1 || '%' 
        OR contact_person ILIKE '%' || $1 || '%'
    )
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchSuppliersParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchSuppliers(ctx context.Context, arg SearchSuppliersParams) ([]Supplier, error) {
	rows, err := q.db.QueryContext(ctx, searchSuppliers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.SupplierID,
			&i.Code,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.TaxID,
			&i.PaymentTerms,
			&i.LeadTimeDays,
			&i.Rating,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSupplier = `-- name: UpdateSupplier :one
UPDATE suppliers 
SET 
    name = COALESCE($2, name),
    contact_person = COALESCE($3, contact_person),
    email = COALESCE($4, email),
    phone = COALESCE($5, phone),
    address = COALESCE($6, address),
    tax_id = COALESCE($7, tax_id),
    payment_terms = COALESCE($8, payment_terms),
    lead_time_days = COALESCE($9, lead_time_days),
    rating = COALESCE($10, rating),
    is_active = COALESCE($11, is_active)
WHERE supplier_id = $1
RETURNING supplier_id, code, name, contact_person, email, phone, address, tax_id, payment_terms, lead_time_days, rating, is_active, created_at
`

type UpdateSupplierParams struct {
	SupplierID    int32           `json:"supplier_id"`
	Name          string          `json:"name"`
	ContactPerson sql.NullString  `json:"contact_person"`
	Email         sql.NullString  `json:"email"`
	Phone         sql.NullString  `json:"phone"`
	Address       sql.NullString  `json:"address"`
	TaxID         sql.NullString  `json:"tax_id"`
	PaymentTerms  sql.NullString  `json:"payment_terms"`
	LeadTimeDays  sql.NullInt32   `json:"lead_time_days"`
	Rating        decimal.Decimal `json:"rating"`
	IsActive      bool            `json:"is_active"`
}

func (q *Queries) UpdateSupplier(ctx context.Context, arg UpdateSupplierParams) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, updateSupplier,
		arg.SupplierID,
		arg.Name,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.TaxID,
		arg.PaymentTerms,
		arg.LeadTimeDays,
		arg.Rating,
		arg.IsActive,
	)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.Code,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.TaxID,
		&i.PaymentTerms,
		&i.LeadTimeDays,
		&i.Rating,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}
