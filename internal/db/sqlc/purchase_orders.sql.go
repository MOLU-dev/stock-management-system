// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: purchase_orders.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createPurchaseOrder = `-- name: CreatePurchaseOrder :one
INSERT INTO purchase_orders (
    po_number, supplier_id, order_date, expected_delivery_date,
    status, total_amount, notes, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING po_id, po_number, supplier_id, order_date, expected_delivery_date, status, total_amount, notes, created_by, created_at
`

type CreatePurchaseOrderParams struct {
	PoNumber             string                  `json:"po_number"`
	SupplierID           int32                   `json:"supplier_id"`
	OrderDate            time.Time               `json:"order_date"`
	ExpectedDeliveryDate time.Time               `json:"expected_delivery_date"`
	Status               NullPurchaseOrderStatus `json:"status"`
	TotalAmount          decimal.Decimal         `json:"total_amount"`
	Notes                pgtype.Text             `json:"notes"`
	CreatedBy            pgtype.Int4             `json:"created_by"`
}

func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg *CreatePurchaseOrderParams) (*PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrder,
		arg.PoNumber,
		arg.SupplierID,
		arg.OrderDate,
		arg.ExpectedDeliveryDate,
		arg.Status,
		arg.TotalAmount,
		arg.Notes,
		arg.CreatedBy,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.PoID,
		&i.PoNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}

const createPurchaseOrderItem = `-- name: CreatePurchaseOrderItem :one
INSERT INTO purchase_order_items (
    po_id, product_id, quantity_ordered, quantity_received,
    unit_price, total_price
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING po_item_id, po_id, product_id, quantity_ordered, quantity_received, unit_price, total_price
`

type CreatePurchaseOrderItemParams struct {
	PoID             int32           `json:"po_id"`
	ProductID        int32           `json:"product_id"`
	QuantityOrdered  int32           `json:"quantity_ordered"`
	QuantityReceived pgtype.Int4     `json:"quantity_received"`
	UnitPrice        decimal.Decimal `json:"unit_price"`
	TotalPrice       decimal.Decimal `json:"total_price"`
}

func (q *Queries) CreatePurchaseOrderItem(ctx context.Context, arg *CreatePurchaseOrderItemParams) (*PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrderItem,
		arg.PoID,
		arg.ProductID,
		arg.QuantityOrdered,
		arg.QuantityReceived,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.PoItemID,
		&i.PoID,
		&i.ProductID,
		&i.QuantityOrdered,
		&i.QuantityReceived,
		&i.UnitPrice,
		&i.TotalPrice,
	)
	return &i, err
}

const getPurchaseOrder = `-- name: GetPurchaseOrder :one
SELECT po.po_id, po.po_number, po.supplier_id, po.order_date, po.expected_delivery_date, po.status, po.total_amount, po.notes, po.created_by, po.created_at, s.name as supplier_name, s.code as supplier_code,
       u.full_name as creator_name
FROM purchase_orders po
LEFT JOIN suppliers s ON po.supplier_id = s.supplier_id
LEFT JOIN users u ON po.created_by = u.user_id
WHERE po.po_id = $1
`

type GetPurchaseOrderRow struct {
	PoID                 int32                   `json:"po_id"`
	PoNumber             string                  `json:"po_number"`
	SupplierID           int32                   `json:"supplier_id"`
	OrderDate            time.Time               `json:"order_date"`
	ExpectedDeliveryDate time.Time               `json:"expected_delivery_date"`
	Status               NullPurchaseOrderStatus `json:"status"`
	TotalAmount          decimal.Decimal         `json:"total_amount"`
	Notes                pgtype.Text             `json:"notes"`
	CreatedBy            pgtype.Int4             `json:"created_by"`
	CreatedAt            time.Time               `json:"created_at"`
	SupplierName         pgtype.Text             `json:"supplier_name"`
	SupplierCode         pgtype.Text             `json:"supplier_code"`
	CreatorName          pgtype.Text             `json:"creator_name"`
}

func (q *Queries) GetPurchaseOrder(ctx context.Context, poID int32) (*GetPurchaseOrderRow, error) {
	row := q.db.QueryRow(ctx, getPurchaseOrder, poID)
	var i GetPurchaseOrderRow
	err := row.Scan(
		&i.PoID,
		&i.PoNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.SupplierName,
		&i.SupplierCode,
		&i.CreatorName,
	)
	return &i, err
}

const getPurchaseOrderItems = `-- name: GetPurchaseOrderItems :many
SELECT poi.po_item_id, poi.po_id, poi.product_id, poi.quantity_ordered, poi.quantity_received, poi.unit_price, poi.total_price, p.name as product_name, p.sku
FROM purchase_order_items poi
JOIN products p ON poi.product_id = p.product_id
WHERE poi.po_id = $1
ORDER BY poi.po_item_id
`

type GetPurchaseOrderItemsRow struct {
	PoItemID         int32           `json:"po_item_id"`
	PoID             int32           `json:"po_id"`
	ProductID        int32           `json:"product_id"`
	QuantityOrdered  int32           `json:"quantity_ordered"`
	QuantityReceived pgtype.Int4     `json:"quantity_received"`
	UnitPrice        decimal.Decimal `json:"unit_price"`
	TotalPrice       decimal.Decimal `json:"total_price"`
	ProductName      string          `json:"product_name"`
	Sku              string          `json:"sku"`
}

func (q *Queries) GetPurchaseOrderItems(ctx context.Context, poID int32) ([]*GetPurchaseOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getPurchaseOrderItems, poID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPurchaseOrderItemsRow
	for rows.Next() {
		var i GetPurchaseOrderItemsRow
		if err := rows.Scan(
			&i.PoItemID,
			&i.PoID,
			&i.ProductID,
			&i.QuantityOrdered,
			&i.QuantityReceived,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.ProductName,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrders = `-- name: ListPurchaseOrders :many
SELECT po.po_id, po.po_number, po.supplier_id, po.order_date, po.expected_delivery_date, po.status, po.total_amount, po.notes, po.created_by, po.created_at, s.name as supplier_name
FROM purchase_orders po
LEFT JOIN suppliers s ON po.supplier_id = s.supplier_id
ORDER BY po.order_date DESC
LIMIT $1 OFFSET $2
`

type ListPurchaseOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPurchaseOrdersRow struct {
	PoID                 int32                   `json:"po_id"`
	PoNumber             string                  `json:"po_number"`
	SupplierID           int32                   `json:"supplier_id"`
	OrderDate            time.Time               `json:"order_date"`
	ExpectedDeliveryDate time.Time               `json:"expected_delivery_date"`
	Status               NullPurchaseOrderStatus `json:"status"`
	TotalAmount          decimal.Decimal         `json:"total_amount"`
	Notes                pgtype.Text             `json:"notes"`
	CreatedBy            pgtype.Int4             `json:"created_by"`
	CreatedAt            time.Time               `json:"created_at"`
	SupplierName         pgtype.Text             `json:"supplier_name"`
}

func (q *Queries) ListPurchaseOrders(ctx context.Context, arg *ListPurchaseOrdersParams) ([]*ListPurchaseOrdersRow, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListPurchaseOrdersRow
	for rows.Next() {
		var i ListPurchaseOrdersRow
		if err := rows.Scan(
			&i.PoID,
			&i.PoNumber,
			&i.SupplierID,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.Status,
			&i.TotalAmount,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrdersByStatus = `-- name: ListPurchaseOrdersByStatus :many
SELECT po.po_id, po.po_number, po.supplier_id, po.order_date, po.expected_delivery_date, po.status, po.total_amount, po.notes, po.created_by, po.created_at, s.name as supplier_name
FROM purchase_orders po
LEFT JOIN suppliers s ON po.supplier_id = s.supplier_id
WHERE po.status = $1
ORDER BY po.order_date DESC
LIMIT $2 OFFSET $3
`

type ListPurchaseOrdersByStatusParams struct {
	Status NullPurchaseOrderStatus `json:"status"`
	Limit  int32                   `json:"limit"`
	Offset int32                   `json:"offset"`
}

type ListPurchaseOrdersByStatusRow struct {
	PoID                 int32                   `json:"po_id"`
	PoNumber             string                  `json:"po_number"`
	SupplierID           int32                   `json:"supplier_id"`
	OrderDate            time.Time               `json:"order_date"`
	ExpectedDeliveryDate time.Time               `json:"expected_delivery_date"`
	Status               NullPurchaseOrderStatus `json:"status"`
	TotalAmount          decimal.Decimal         `json:"total_amount"`
	Notes                pgtype.Text             `json:"notes"`
	CreatedBy            pgtype.Int4             `json:"created_by"`
	CreatedAt            time.Time               `json:"created_at"`
	SupplierName         pgtype.Text             `json:"supplier_name"`
}

func (q *Queries) ListPurchaseOrdersByStatus(ctx context.Context, arg *ListPurchaseOrdersByStatusParams) ([]*ListPurchaseOrdersByStatusRow, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrdersByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListPurchaseOrdersByStatusRow
	for rows.Next() {
		var i ListPurchaseOrdersByStatusRow
		if err := rows.Scan(
			&i.PoID,
			&i.PoNumber,
			&i.SupplierID,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.Status,
			&i.TotalAmount,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePurchaseOrderItemReceivedQty = `-- name: UpdatePurchaseOrderItemReceivedQty :one
UPDATE purchase_order_items 
SET 
    quantity_received = quantity_received + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE po_item_id = $1
RETURNING po_item_id, po_id, product_id, quantity_ordered, quantity_received, unit_price, total_price
`

type UpdatePurchaseOrderItemReceivedQtyParams struct {
	PoItemID         int32       `json:"po_item_id"`
	QuantityReceived pgtype.Int4 `json:"quantity_received"`
}

func (q *Queries) UpdatePurchaseOrderItemReceivedQty(ctx context.Context, arg *UpdatePurchaseOrderItemReceivedQtyParams) (*PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, updatePurchaseOrderItemReceivedQty, arg.PoItemID, arg.QuantityReceived)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.PoItemID,
		&i.PoID,
		&i.ProductID,
		&i.QuantityOrdered,
		&i.QuantityReceived,
		&i.UnitPrice,
		&i.TotalPrice,
	)
	return &i, err
}

const updatePurchaseOrderStatus = `-- name: UpdatePurchaseOrderStatus :one
UPDATE purchase_orders 
SET 
    status = $2,
    total_amount = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE po_id = $1
RETURNING po_id, po_number, supplier_id, order_date, expected_delivery_date, status, total_amount, notes, created_by, created_at
`

type UpdatePurchaseOrderStatusParams struct {
	PoID        int32                   `json:"po_id"`
	Status      NullPurchaseOrderStatus `json:"status"`
	TotalAmount decimal.Decimal         `json:"total_amount"`
}

func (q *Queries) UpdatePurchaseOrderStatus(ctx context.Context, arg *UpdatePurchaseOrderStatusParams) (*PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, updatePurchaseOrderStatus, arg.PoID, arg.Status, arg.TotalAmount)
	var i PurchaseOrder
	err := row.Scan(
		&i.PoID,
		&i.PoNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}
