// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getInventory = `-- name: GetInventory :one
SELECT inventory_id, product_id, warehouse_id, location_id, quantity, reserved_quantity, batch_number, expiry_date, manufacturing_date, serial_number, status, last_counted_date, created_at, updated_at FROM inventory 
WHERE inventory_id = $1
`

func (q *Queries) GetInventory(ctx context.Context, inventoryID int32) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getInventory, inventoryID)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.ManufacturingDate,
		&i.SerialNumber,
		&i.Status,
		&i.LastCountedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryByLocation = `-- name: GetInventoryByLocation :one
SELECT inventory_id, product_id, warehouse_id, location_id, quantity, reserved_quantity, batch_number, expiry_date, manufacturing_date, serial_number, status, last_counted_date, created_at, updated_at FROM inventory 
WHERE product_id = $1 AND warehouse_id = $2 AND location_id = $3
`

type GetInventoryByLocationParams struct {
	ProductID   int32         `json:"product_id"`
	WarehouseID int32         `json:"warehouse_id"`
	LocationID  sql.NullInt32 `json:"location_id"`
}

func (q *Queries) GetInventoryByLocation(ctx context.Context, arg GetInventoryByLocationParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getInventoryByLocation, arg.ProductID, arg.WarehouseID, arg.LocationID)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.ManufacturingDate,
		&i.SerialNumber,
		&i.Status,
		&i.LastCountedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryByProductWarehouse = `-- name: GetInventoryByProductWarehouse :one
SELECT inventory_id, product_id, warehouse_id, location_id, quantity, reserved_quantity, batch_number, expiry_date, manufacturing_date, serial_number, status, last_counted_date, created_at, updated_at FROM inventory 
WHERE product_id = $1 AND warehouse_id = $2
`

type GetInventoryByProductWarehouseParams struct {
	ProductID   int32 `json:"product_id"`
	WarehouseID int32 `json:"warehouse_id"`
}

func (q *Queries) GetInventoryByProductWarehouse(ctx context.Context, arg GetInventoryByProductWarehouseParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getInventoryByProductWarehouse, arg.ProductID, arg.WarehouseID)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.ManufacturingDate,
		&i.SerialNumber,
		&i.Status,
		&i.LastCountedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listExpiringInventory = `-- name: ListExpiringInventory :many
SELECT i.inventory_id, i.product_id, i.warehouse_id, i.location_id, i.quantity, i.reserved_quantity, i.batch_number, i.expiry_date, i.manufacturing_date, i.serial_number, i.status, i.last_counted_date, i.created_at, i.updated_at, p.name as product_name, p.sku, 
       w.name as warehouse_name, w.code as warehouse_code
FROM inventory i
JOIN products p ON i.product_id = p.product_id
JOIN warehouses w ON i.warehouse_id = w.warehouse_id
WHERE i.expiry_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days'
  AND i.status = 'in_stock'
  AND p.is_active = true
  AND w.is_active = true
ORDER BY i.expiry_date
`

type ListExpiringInventoryRow struct {
	InventoryID       int32           `json:"inventory_id"`
	ProductID         int32           `json:"product_id"`
	WarehouseID       int32           `json:"warehouse_id"`
	LocationID        sql.NullInt32   `json:"location_id"`
	Quantity          int32           `json:"quantity"`
	ReservedQuantity  int32           `json:"reserved_quantity"`
	BatchNumber       sql.NullString  `json:"batch_number"`
	ExpiryDate        time.Time       `json:"expiry_date"`
	ManufacturingDate time.Time       `json:"manufacturing_date"`
	SerialNumber      sql.NullString  `json:"serial_number"`
	Status            InventoryStatus `json:"status"`
	LastCountedDate   time.Time       `json:"last_counted_date"`
	CreatedAt         time.Time       `json:"created_at"`
	UpdatedAt         time.Time       `json:"updated_at"`
	ProductName       string          `json:"product_name"`
	Sku               string          `json:"sku"`
	WarehouseName     string          `json:"warehouse_name"`
	WarehouseCode     string          `json:"warehouse_code"`
}

func (q *Queries) ListExpiringInventory(ctx context.Context) ([]ListExpiringInventoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listExpiringInventory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpiringInventoryRow
	for rows.Next() {
		var i ListExpiringInventoryRow
		if err := rows.Scan(
			&i.InventoryID,
			&i.ProductID,
			&i.WarehouseID,
			&i.LocationID,
			&i.Quantity,
			&i.ReservedQuantity,
			&i.BatchNumber,
			&i.ExpiryDate,
			&i.ManufacturingDate,
			&i.SerialNumber,
			&i.Status,
			&i.LastCountedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.Sku,
			&i.WarehouseName,
			&i.WarehouseCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryByProduct = `-- name: ListInventoryByProduct :many
SELECT i.inventory_id, i.product_id, i.warehouse_id, i.location_id, i.quantity, i.reserved_quantity, i.batch_number, i.expiry_date, i.manufacturing_date, i.serial_number, i.status, i.last_counted_date, i.created_at, i.updated_at, w.name as warehouse_name, w.code as warehouse_code
FROM inventory i
JOIN warehouses w ON i.warehouse_id = w.warehouse_id
WHERE i.product_id = $1 AND w.is_active = true
ORDER BY i.warehouse_id
`

type ListInventoryByProductRow struct {
	InventoryID       int32           `json:"inventory_id"`
	ProductID         int32           `json:"product_id"`
	WarehouseID       int32           `json:"warehouse_id"`
	LocationID        sql.NullInt32   `json:"location_id"`
	Quantity          int32           `json:"quantity"`
	ReservedQuantity  int32           `json:"reserved_quantity"`
	BatchNumber       sql.NullString  `json:"batch_number"`
	ExpiryDate        time.Time       `json:"expiry_date"`
	ManufacturingDate time.Time       `json:"manufacturing_date"`
	SerialNumber      sql.NullString  `json:"serial_number"`
	Status            InventoryStatus `json:"status"`
	LastCountedDate   time.Time       `json:"last_counted_date"`
	CreatedAt         time.Time       `json:"created_at"`
	UpdatedAt         time.Time       `json:"updated_at"`
	WarehouseName     string          `json:"warehouse_name"`
	WarehouseCode     string          `json:"warehouse_code"`
}

func (q *Queries) ListInventoryByProduct(ctx context.Context, productID int32) ([]ListInventoryByProductRow, error) {
	rows, err := q.db.QueryContext(ctx, listInventoryByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryByProductRow
	for rows.Next() {
		var i ListInventoryByProductRow
		if err := rows.Scan(
			&i.InventoryID,
			&i.ProductID,
			&i.WarehouseID,
			&i.LocationID,
			&i.Quantity,
			&i.ReservedQuantity,
			&i.BatchNumber,
			&i.ExpiryDate,
			&i.ManufacturingDate,
			&i.SerialNumber,
			&i.Status,
			&i.LastCountedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WarehouseName,
			&i.WarehouseCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryByWarehouse = `-- name: ListInventoryByWarehouse :many
SELECT i.inventory_id, i.product_id, i.warehouse_id, i.location_id, i.quantity, i.reserved_quantity, i.batch_number, i.expiry_date, i.manufacturing_date, i.serial_number, i.status, i.last_counted_date, i.created_at, i.updated_at, p.name as product_name, p.sku
FROM inventory i
JOIN products p ON i.product_id = p.product_id
WHERE i.warehouse_id = $1 AND p.is_active = true
ORDER BY i.product_id
LIMIT $2 OFFSET $3
`

type ListInventoryByWarehouseParams struct {
	WarehouseID int32 `json:"warehouse_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type ListInventoryByWarehouseRow struct {
	InventoryID       int32           `json:"inventory_id"`
	ProductID         int32           `json:"product_id"`
	WarehouseID       int32           `json:"warehouse_id"`
	LocationID        sql.NullInt32   `json:"location_id"`
	Quantity          int32           `json:"quantity"`
	ReservedQuantity  int32           `json:"reserved_quantity"`
	BatchNumber       sql.NullString  `json:"batch_number"`
	ExpiryDate        time.Time       `json:"expiry_date"`
	ManufacturingDate time.Time       `json:"manufacturing_date"`
	SerialNumber      sql.NullString  `json:"serial_number"`
	Status            InventoryStatus `json:"status"`
	LastCountedDate   time.Time       `json:"last_counted_date"`
	CreatedAt         time.Time       `json:"created_at"`
	UpdatedAt         time.Time       `json:"updated_at"`
	ProductName       string          `json:"product_name"`
	Sku               string          `json:"sku"`
}

func (q *Queries) ListInventoryByWarehouse(ctx context.Context, arg ListInventoryByWarehouseParams) ([]ListInventoryByWarehouseRow, error) {
	rows, err := q.db.QueryContext(ctx, listInventoryByWarehouse, arg.WarehouseID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryByWarehouseRow
	for rows.Next() {
		var i ListInventoryByWarehouseRow
		if err := rows.Scan(
			&i.InventoryID,
			&i.ProductID,
			&i.WarehouseID,
			&i.LocationID,
			&i.Quantity,
			&i.ReservedQuantity,
			&i.BatchNumber,
			&i.ExpiryDate,
			&i.ManufacturingDate,
			&i.SerialNumber,
			&i.Status,
			&i.LastCountedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseInventoryReservation = `-- name: ReleaseInventoryReservation :one
UPDATE inventory 
SET 
    reserved_quantity = reserved_quantity - $2,
    updated_at = CURRENT_TIMESTAMP
WHERE inventory_id = $1 AND reserved_quantity >= $2
RETURNING inventory_id, product_id, warehouse_id, location_id, quantity, reserved_quantity, batch_number, expiry_date, manufacturing_date, serial_number, status, last_counted_date, created_at, updated_at
`

type ReleaseInventoryReservationParams struct {
	InventoryID      int32 `json:"inventory_id"`
	ReservedQuantity int32 `json:"reserved_quantity"`
}

func (q *Queries) ReleaseInventoryReservation(ctx context.Context, arg ReleaseInventoryReservationParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, releaseInventoryReservation, arg.InventoryID, arg.ReservedQuantity)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.ManufacturingDate,
		&i.SerialNumber,
		&i.Status,
		&i.LastCountedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const reserveInventory = `-- name: ReserveInventory :one
UPDATE inventory 
SET 
    reserved_quantity = reserved_quantity + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE inventory_id = $1 AND (quantity - reserved_quantity) >= $2
RETURNING inventory_id, product_id, warehouse_id, location_id, quantity, reserved_quantity, batch_number, expiry_date, manufacturing_date, serial_number, status, last_counted_date, created_at, updated_at
`

type ReserveInventoryParams struct {
	InventoryID      int32 `json:"inventory_id"`
	ReservedQuantity int32 `json:"reserved_quantity"`
}

func (q *Queries) ReserveInventory(ctx context.Context, arg ReserveInventoryParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, reserveInventory, arg.InventoryID, arg.ReservedQuantity)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.ManufacturingDate,
		&i.SerialNumber,
		&i.Status,
		&i.LastCountedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInventoryQuantity = `-- name: UpdateInventoryQuantity :one
UPDATE inventory 
SET 
    quantity = $2,
    reserved_quantity = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE inventory_id = $1
RETURNING inventory_id, product_id, warehouse_id, location_id, quantity, reserved_quantity, batch_number, expiry_date, manufacturing_date, serial_number, status, last_counted_date, created_at, updated_at
`

type UpdateInventoryQuantityParams struct {
	InventoryID      int32 `json:"inventory_id"`
	Quantity         int32 `json:"quantity"`
	ReservedQuantity int32 `json:"reserved_quantity"`
}

func (q *Queries) UpdateInventoryQuantity(ctx context.Context, arg UpdateInventoryQuantityParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryQuantity, arg.InventoryID, arg.Quantity, arg.ReservedQuantity)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.ManufacturingDate,
		&i.SerialNumber,
		&i.Status,
		&i.LastCountedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInventoryStatus = `-- name: UpdateInventoryStatus :one
UPDATE inventory 
SET 
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE inventory_id = $1
RETURNING inventory_id, product_id, warehouse_id, location_id, quantity, reserved_quantity, batch_number, expiry_date, manufacturing_date, serial_number, status, last_counted_date, created_at, updated_at
`

type UpdateInventoryStatusParams struct {
	InventoryID int32           `json:"inventory_id"`
	Status      InventoryStatus `json:"status"`
}

func (q *Queries) UpdateInventoryStatus(ctx context.Context, arg UpdateInventoryStatusParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryStatus, arg.InventoryID, arg.Status)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.ManufacturingDate,
		&i.SerialNumber,
		&i.Status,
		&i.LastCountedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
