// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stock_movements.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createStockMovement = `-- name: CreateStockMovement :one
INSERT INTO stock_movements (
    reference_number, product_id, warehouse_id, location_id,
    movement_type, quantity_before, quantity_change, quantity_after,
    reference_id, reference_table, notes, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING movement_id, reference_number, product_id, warehouse_id, location_id, movement_type, quantity_before, quantity_change, quantity_after, reference_id, reference_table, notes, movement_date, created_by
`

type CreateStockMovementParams struct {
	ReferenceNumber sql.NullString `json:"reference_number"`
	ProductID       int32          `json:"product_id"`
	WarehouseID     int32          `json:"warehouse_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	MovementType    MovementType   `json:"movement_type"`
	QuantityBefore  sql.NullInt32  `json:"quantity_before"`
	QuantityChange  int32          `json:"quantity_change"`
	QuantityAfter   sql.NullInt32  `json:"quantity_after"`
	ReferenceID     sql.NullInt32  `json:"reference_id"`
	ReferenceTable  sql.NullString `json:"reference_table"`
	Notes           sql.NullString `json:"notes"`
	CreatedBy       sql.NullInt32  `json:"created_by"`
}

func (q *Queries) CreateStockMovement(ctx context.Context, arg CreateStockMovementParams) (StockMovement, error) {
	row := q.db.QueryRowContext(ctx, createStockMovement,
		arg.ReferenceNumber,
		arg.ProductID,
		arg.WarehouseID,
		arg.LocationID,
		arg.MovementType,
		arg.QuantityBefore,
		arg.QuantityChange,
		arg.QuantityAfter,
		arg.ReferenceID,
		arg.ReferenceTable,
		arg.Notes,
		arg.CreatedBy,
	)
	var i StockMovement
	err := row.Scan(
		&i.MovementID,
		&i.ReferenceNumber,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.MovementType,
		&i.QuantityBefore,
		&i.QuantityChange,
		&i.QuantityAfter,
		&i.ReferenceID,
		&i.ReferenceTable,
		&i.Notes,
		&i.MovementDate,
		&i.CreatedBy,
	)
	return i, err
}

const getProductMovementHistory = `-- name: GetProductMovementHistory :many
SELECT sm.movement_id, sm.reference_number, sm.product_id, sm.warehouse_id, sm.location_id, sm.movement_type, sm.quantity_before, sm.quantity_change, sm.quantity_after, sm.reference_id, sm.reference_table, sm.notes, sm.movement_date, sm.created_by, w.name as warehouse_name
FROM stock_movements sm
JOIN warehouses w ON sm.warehouse_id = w.warehouse_id
WHERE sm.product_id = $1 AND sm.warehouse_id = $2
ORDER BY sm.movement_date DESC
LIMIT $3 OFFSET $4
`

type GetProductMovementHistoryParams struct {
	ProductID   int32 `json:"product_id"`
	WarehouseID int32 `json:"warehouse_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetProductMovementHistoryRow struct {
	MovementID      int32          `json:"movement_id"`
	ReferenceNumber sql.NullString `json:"reference_number"`
	ProductID       int32          `json:"product_id"`
	WarehouseID     int32          `json:"warehouse_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	MovementType    MovementType   `json:"movement_type"`
	QuantityBefore  sql.NullInt32  `json:"quantity_before"`
	QuantityChange  int32          `json:"quantity_change"`
	QuantityAfter   sql.NullInt32  `json:"quantity_after"`
	ReferenceID     sql.NullInt32  `json:"reference_id"`
	ReferenceTable  sql.NullString `json:"reference_table"`
	Notes           sql.NullString `json:"notes"`
	MovementDate    time.Time      `json:"movement_date"`
	CreatedBy       sql.NullInt32  `json:"created_by"`
	WarehouseName   string         `json:"warehouse_name"`
}

func (q *Queries) GetProductMovementHistory(ctx context.Context, arg GetProductMovementHistoryParams) ([]GetProductMovementHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductMovementHistory,
		arg.ProductID,
		arg.WarehouseID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductMovementHistoryRow
	for rows.Next() {
		var i GetProductMovementHistoryRow
		if err := rows.Scan(
			&i.MovementID,
			&i.ReferenceNumber,
			&i.ProductID,
			&i.WarehouseID,
			&i.LocationID,
			&i.MovementType,
			&i.QuantityBefore,
			&i.QuantityChange,
			&i.QuantityAfter,
			&i.ReferenceID,
			&i.ReferenceTable,
			&i.Notes,
			&i.MovementDate,
			&i.CreatedBy,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockMovement = `-- name: GetStockMovement :one
SELECT movement_id, reference_number, product_id, warehouse_id, location_id, movement_type, quantity_before, quantity_change, quantity_after, reference_id, reference_table, notes, movement_date, created_by FROM stock_movements 
WHERE movement_id = $1
`

func (q *Queries) GetStockMovement(ctx context.Context, movementID int32) (StockMovement, error) {
	row := q.db.QueryRowContext(ctx, getStockMovement, movementID)
	var i StockMovement
	err := row.Scan(
		&i.MovementID,
		&i.ReferenceNumber,
		&i.ProductID,
		&i.WarehouseID,
		&i.LocationID,
		&i.MovementType,
		&i.QuantityBefore,
		&i.QuantityChange,
		&i.QuantityAfter,
		&i.ReferenceID,
		&i.ReferenceTable,
		&i.Notes,
		&i.MovementDate,
		&i.CreatedBy,
	)
	return i, err
}

const listStockMovementsByProduct = `-- name: ListStockMovementsByProduct :many
SELECT sm.movement_id, sm.reference_number, sm.product_id, sm.warehouse_id, sm.location_id, sm.movement_type, sm.quantity_before, sm.quantity_change, sm.quantity_after, sm.reference_id, sm.reference_table, sm.notes, sm.movement_date, sm.created_by, p.name as product_name, p.sku, w.name as warehouse_name
FROM stock_movements sm
JOIN products p ON sm.product_id = p.product_id
JOIN warehouses w ON sm.warehouse_id = w.warehouse_id
WHERE sm.product_id = $1
ORDER BY sm.movement_date DESC
LIMIT $2 OFFSET $3
`

type ListStockMovementsByProductParams struct {
	ProductID int32 `json:"product_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListStockMovementsByProductRow struct {
	MovementID      int32          `json:"movement_id"`
	ReferenceNumber sql.NullString `json:"reference_number"`
	ProductID       int32          `json:"product_id"`
	WarehouseID     int32          `json:"warehouse_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	MovementType    MovementType   `json:"movement_type"`
	QuantityBefore  sql.NullInt32  `json:"quantity_before"`
	QuantityChange  int32          `json:"quantity_change"`
	QuantityAfter   sql.NullInt32  `json:"quantity_after"`
	ReferenceID     sql.NullInt32  `json:"reference_id"`
	ReferenceTable  sql.NullString `json:"reference_table"`
	Notes           sql.NullString `json:"notes"`
	MovementDate    time.Time      `json:"movement_date"`
	CreatedBy       sql.NullInt32  `json:"created_by"`
	ProductName     string         `json:"product_name"`
	Sku             string         `json:"sku"`
	WarehouseName   string         `json:"warehouse_name"`
}

func (q *Queries) ListStockMovementsByProduct(ctx context.Context, arg ListStockMovementsByProductParams) ([]ListStockMovementsByProductRow, error) {
	rows, err := q.db.QueryContext(ctx, listStockMovementsByProduct, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockMovementsByProductRow
	for rows.Next() {
		var i ListStockMovementsByProductRow
		if err := rows.Scan(
			&i.MovementID,
			&i.ReferenceNumber,
			&i.ProductID,
			&i.WarehouseID,
			&i.LocationID,
			&i.MovementType,
			&i.QuantityBefore,
			&i.QuantityChange,
			&i.QuantityAfter,
			&i.ReferenceID,
			&i.ReferenceTable,
			&i.Notes,
			&i.MovementDate,
			&i.CreatedBy,
			&i.ProductName,
			&i.Sku,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockMovementsByType = `-- name: ListStockMovementsByType :many
SELECT sm.movement_id, sm.reference_number, sm.product_id, sm.warehouse_id, sm.location_id, sm.movement_type, sm.quantity_before, sm.quantity_change, sm.quantity_after, sm.reference_id, sm.reference_table, sm.notes, sm.movement_date, sm.created_by, p.name as product_name, p.sku, w.name as warehouse_name
FROM stock_movements sm
JOIN products p ON sm.product_id = p.product_id
JOIN warehouses w ON sm.warehouse_id = w.warehouse_id
WHERE sm.movement_type = $1
ORDER BY sm.movement_date DESC
LIMIT $2 OFFSET $3
`

type ListStockMovementsByTypeParams struct {
	MovementType MovementType `json:"movement_type"`
	Limit        int32        `json:"limit"`
	Offset       int32        `json:"offset"`
}

type ListStockMovementsByTypeRow struct {
	MovementID      int32          `json:"movement_id"`
	ReferenceNumber sql.NullString `json:"reference_number"`
	ProductID       int32          `json:"product_id"`
	WarehouseID     int32          `json:"warehouse_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	MovementType    MovementType   `json:"movement_type"`
	QuantityBefore  sql.NullInt32  `json:"quantity_before"`
	QuantityChange  int32          `json:"quantity_change"`
	QuantityAfter   sql.NullInt32  `json:"quantity_after"`
	ReferenceID     sql.NullInt32  `json:"reference_id"`
	ReferenceTable  sql.NullString `json:"reference_table"`
	Notes           sql.NullString `json:"notes"`
	MovementDate    time.Time      `json:"movement_date"`
	CreatedBy       sql.NullInt32  `json:"created_by"`
	ProductName     string         `json:"product_name"`
	Sku             string         `json:"sku"`
	WarehouseName   string         `json:"warehouse_name"`
}

func (q *Queries) ListStockMovementsByType(ctx context.Context, arg ListStockMovementsByTypeParams) ([]ListStockMovementsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, listStockMovementsByType, arg.MovementType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockMovementsByTypeRow
	for rows.Next() {
		var i ListStockMovementsByTypeRow
		if err := rows.Scan(
			&i.MovementID,
			&i.ReferenceNumber,
			&i.ProductID,
			&i.WarehouseID,
			&i.LocationID,
			&i.MovementType,
			&i.QuantityBefore,
			&i.QuantityChange,
			&i.QuantityAfter,
			&i.ReferenceID,
			&i.ReferenceTable,
			&i.Notes,
			&i.MovementDate,
			&i.CreatedBy,
			&i.ProductName,
			&i.Sku,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockMovementsByWarehouse = `-- name: ListStockMovementsByWarehouse :many
SELECT sm.movement_id, sm.reference_number, sm.product_id, sm.warehouse_id, sm.location_id, sm.movement_type, sm.quantity_before, sm.quantity_change, sm.quantity_after, sm.reference_id, sm.reference_table, sm.notes, sm.movement_date, sm.created_by, p.name as product_name, p.sku
FROM stock_movements sm
JOIN products p ON sm.product_id = p.product_id
WHERE sm.warehouse_id = $1
ORDER BY sm.movement_date DESC
LIMIT $2 OFFSET $3
`

type ListStockMovementsByWarehouseParams struct {
	WarehouseID int32 `json:"warehouse_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type ListStockMovementsByWarehouseRow struct {
	MovementID      int32          `json:"movement_id"`
	ReferenceNumber sql.NullString `json:"reference_number"`
	ProductID       int32          `json:"product_id"`
	WarehouseID     int32          `json:"warehouse_id"`
	LocationID      sql.NullInt32  `json:"location_id"`
	MovementType    MovementType   `json:"movement_type"`
	QuantityBefore  sql.NullInt32  `json:"quantity_before"`
	QuantityChange  int32          `json:"quantity_change"`
	QuantityAfter   sql.NullInt32  `json:"quantity_after"`
	ReferenceID     sql.NullInt32  `json:"reference_id"`
	ReferenceTable  sql.NullString `json:"reference_table"`
	Notes           sql.NullString `json:"notes"`
	MovementDate    time.Time      `json:"movement_date"`
	CreatedBy       sql.NullInt32  `json:"created_by"`
	ProductName     string         `json:"product_name"`
	Sku             string         `json:"sku"`
}

func (q *Queries) ListStockMovementsByWarehouse(ctx context.Context, arg ListStockMovementsByWarehouseParams) ([]ListStockMovementsByWarehouseRow, error) {
	rows, err := q.db.QueryContext(ctx, listStockMovementsByWarehouse, arg.WarehouseID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockMovementsByWarehouseRow
	for rows.Next() {
		var i ListStockMovementsByWarehouseRow
		if err := rows.Scan(
			&i.MovementID,
			&i.ReferenceNumber,
			&i.ProductID,
			&i.WarehouseID,
			&i.LocationID,
			&i.MovementType,
			&i.QuantityBefore,
			&i.QuantityChange,
			&i.QuantityAfter,
			&i.ReferenceID,
			&i.ReferenceTable,
			&i.Notes,
			&i.MovementDate,
			&i.CreatedBy,
			&i.ProductName,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
